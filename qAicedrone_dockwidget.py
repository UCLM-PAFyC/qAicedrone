# -*- coding: utf-8 -*-
"""
/***************************************************************************
 qAicedroneDockWidget
                                 A QGIS plugin
 A plugin for AICEDRONE project
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-06-13
        git sha              : $Format:%H$
        copyright            : (C) 2019 by David Hernandez Lopez, Universidad de Castilla-La Mancha
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# dhl
import sys, os
from .resources_rc import *
from osgeo import osr
from decimal import Decimal
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QFileInfo, QDir, QObject
from PyQt5.QtWidgets import QMessageBox,QFileDialog,QTabWidget,QInputDialog,QLineEdit
from PyQt5.QtWidgets import QDockWidget
from qgis.core import QgsApplication, QgsDataSourceUri,QgsProject, QgsCoordinateReferenceSystem
# pluginsPath = QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path()
# pluginPath = os.path.dirname(os.path.realpath(__file__))
# pluginPath = os.path.join(pluginsPath, pluginPath)
# libCppPath = os.path.join(pluginPath, 'libCpp')
# existsPluginPath = QDir(libCppPath).exists()
# sys.path.append(pluginPath)
# sys.path.append(libCppPath)
# os.environ["PATH"] += os.pathsep + libCppPath
# from libCpp.libPyModelManagementTools import IPyModelManagementToolsProject
from .multipleFileSelectorDialog.multiple_file_selector_dialog import * #panel nueva camara
# from .reports.Report import *
# import MMTDefinitions
from . import MMTDefinitions
from .selectionMapTools.rectangle_map_tool import RectangleMapTool
from .selectionMapTools.polygon_map_tool import PolygonMapTool

#  dhl

import os

from math import floor
import re

from PyQt5 import QtGui, QtWidgets, uic
from PyQt5.QtCore import pyqtSignal

from qgis import utils

from qgis.core import Qgis
qgis_version_number_str = Qgis.QGIS_VERSION.split('-')[0]
qgis_version_first_number = int(qgis_version_number_str.split('.')[0])
qgis_version_second_number = int(qgis_version_number_str.split('.')[1])
qgis_version_third_number = int(qgis_version_number_str.split('.')[2])
qgis_version_second_number_change_buffer_parameters = 20

from osgeo import osr
projVersionMajor = osr.GetPROJVersionMajor()

FORM_CLASS = None

# if projVersionMajor < 8:
#     FORM_CLASS, _ = uic.loadUiType(os.path.join(
#         os.path.dirname(__file__), 'model_management_tools_dockwidget_base_old_osgeo.ui'))
# else:
#     FORM_CLASS, _ = uic.loadUiType(os.path.join(
#         os.path.dirname(__file__), 'model_management_tools_dockwidget_base.ui'))
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'qAicedrone_dockwidget_base.ui'))


class qAicedroneDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self,
                 iface,
                 projVersionMajor,
                 pluginPath,
                 libCppPath,
                 currentPluginName,
                 settings,
                 iPyProject,
                 parent=None):
        """Constructor."""
        super(qAicedroneDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setWindowTitle(MMTDefinitions.CONST_PROGRAM_NAME)
        self.iface = iface
        self.projVersionMajor = projVersionMajor
        self.path_plugin = pluginPath
        self.path_libCpp = libCppPath
        self.current_plugin_name = currentPluginName
        self.settings = settings
        self.iPyProject = iPyProject
        self.isModelManagementPlugin = False
        self.plugin_name = None
        self.referenceLayer = None
        if self.current_plugin_name == MMTDefinitions.CONST_SETTINGS_PLUGIN_NAME:
            self.isModelManagementPlugin = True
            self.plugin_name = MMTDefinitions.CONST_SETTINGS_PLUGIN_NAME
        self.setupUi(self)
        # self.pluginQLidarInstance = None
        self.pluginQLidarInstance = utils.plugins['qLidar']
        self.pluginPhotogrammetryToolsInstance = utils.plugins['photogrammetry_tools']
        self.initialize()

        #### depuracion report
        # report = Report(self.iface,self.path_plugin)
        # reportType = 'PhHotspot'
        # reportSucess, strError = report.initialize(reportType)
        # if not reportSucess:
        #     msgBox = QMessageBox(self)
        #     msgBox.setIcon(QMessageBox.Information)
        #     msgBox.setWindowTitle(self.windowTitle)
        #     msgBox.setText(strError)
        #     msgBox.exec_()
        #     return

        ####

    def addPhotogrammetryConnection(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        items = []
        items.append(MMTDefinitions.CONST_NO_COMBO_SELECT)
        self.getPhotogrammetrySpatialiteConnections()
        for connection in self.photogrammetryConnections.keys():
            if not connection in self.photogrammetryConnectionsInProject:
                items.append(connection)
        item, ok = QInputDialog.getItem(self, "Select Photogrammetry Project",
                                    "Photogrammetry Project:", items, 0, False)
        if ok and item:
            if item == MMTDefinitions.CONST_NO_COMBO_SELECT:
                return
            connectionName = item
            photogrammetrySpatialiteDbFileName = self.photogrammetryConnections[connectionName]
            ret = self.iPyProject.mmtAddPhotogrammetryDb(dbFileName,
                                                         photogrammetrySpatialiteDbFileName)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n"+ret[1])
                msgBox.exec_()
                return
            else:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Process completed successfully")
                msgBox.exec_()
            self.photogrammetryConnectionsInProject[connectionName] = photogrammetrySpatialiteDbFileName
            self.photogrammetriesComboBox.clear()
            self.photogrammetriesComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
            for photogrammetryConnectionInProject in self.photogrammetryConnectionsInProject.keys():
                self.photogrammetriesComboBox.addItem(photogrammetryConnectionInProject)
        return

    def addPointCloud(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        strDir = QFileDialog.getExistingDirectory(self, "Select point cloud path", self.path,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            for pointCloud in self.pointCloudsInProject:
                if pointCloud.lower() == strDir.lower():
                    return
            ret = self.iPyProject.mmtAddPointCloud(dbFileName, strDir)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.pmOutputPathLineEdit.setText("")
                self.projectManagerOutputPath = None
                return
            else:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Process completed successfully")
                msgBox.exec_()
            self.pointCloudsInProject.append(strDir)
            self.pointCloudsComboBox.clear()
            self.pointCloudsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
            for pointCloud in self.pointCloudsInProject:
                self.pointCloudsComboBox.addItem(pointCloud)
            self.projectManagerOutputPath = strDir
            self.settings.setValue("project_management_output_path", self.projectManagerOutputPath)
            self.settings.sync()
            self.pmOutputPathLineEdit.setText(strDir)
        return

    def field_to_value_map(self, vLayer, field, list_values):
        # config = {'map': list_values, 'AllowNull': False}
        config = {'map': list_values}
        widget_setup = QgsEditorWidgetSetup('ValueMap', config)
        field_idx = vLayer.fields().indexFromName(field)
        vLayer.setEditorWidgetSetup(field_idx, widget_setup)
        # pichurri
        form_config = vLayer.editFormConfig()
        form_config.setReuseLastValue(field_idx, True)
        vLayer.setEditFormConfig(form_config)

    def addVirtualRoadMarksLayers(self):
        projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(self.crsEpsgCode)
        catalogueFileNames = []
        # recuperar los ficheros de marcas
        uri = QgsDataSourceUri()
        uri.setDatabase(self.dbFileName)
        schema = ''
        roadMarksTable = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_TABLE_NAME
        roadMarksGeomColumn = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_GEOMETRY_COLUMN
        uri.setDataSource(schema, roadMarksTable, roadMarksGeomColumn)
        roadMarkslayer = QgsVectorLayer(uri.uri(), 'road_marks', 'spatialite')
        if not roadMarkslayer.isValid():
            return # cuando todavia no se han procesado road_marks
        for roadMarkFeature in roadMarkslayer.getFeatures():
            mark_file = roadMarkFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_FIELD_ROAD_MARKS_FILE]
            if not mark_file in catalogueFileNames:
                catalogueFileNames.append(mark_file)
        # recuperar los valores del catalogo
        uri = QgsDataSourceUri()
        uri.setDatabase(self.dbFileName)
        schema = ''
        catalogTable = MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_TABLE_NAME
        catalogGeomColumn = MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_GEOMETRY
        uri.setDataSource(schema, catalogTable, catalogGeomColumn)
        cataloguelayer = QgsVectorLayer(uri.uri(), 'catalogue', 'spatialite')
        if not cataloguelayer.isValid():
            return # cuando todavia no se han procesado road_marks
            # if vlayer.featureCount() == 0:
            #     return
            # QgsProject.instance().addMapLayer(vlayer, False)
            # self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
            # vlayer.loadNamedStyle(self.qmlRoadMarksFileName)
            # vlayer.triggerRepaint()
            # self.iface.setActiveLayer(vlayer)
            # self.iface.zoomToActiveLayer()
        catalogueWidths = []
        catalogueValuesById = {}
        for catalogueFeature in cataloguelayer.getFeatures():
            strId = catalogueFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_ID]
            code = catalogueFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_CODE]
            type = catalogueFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_TYPE]
            strEnabled = catalogueFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_ENABLED]
            strWidth = catalogueFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_WIDTH]
            if MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_TYPE_LONGITUDINAL_SUB_STRING in type:
                if not strWidth in catalogueWidths:
                    width = float(strWidth)
                    catalogueWidths.append(width)
            catalogueValues = {}
            catalogueValues[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_CODE] = code
            catalogueValues[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_TYPE] = type
            if strEnabled == '1':
                catalogueValues[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_ENABLED] = True
            else:
                catalogueValues[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_ENABLED] = False
            # catalogueValues[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_CODE] = code
            id = int(strId)
            catalogueValuesById[id] = catalogueValues

        layerManualEditingLinearRoadMarksTitle = MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_NAME
        layerList = QgsProject.instance().mapLayersByName(layerManualEditingLinearRoadMarksTitle)
        if not layerList:
            self.manualEditingLinearRoadMarksLayer = None
            self.manualEditingLinearRoadMarksLayer = QgsVectorLayer("Linestring?crs=" + projectCrs.authid(),
                                                               layerManualEditingLinearRoadMarksTitle, "memory")
            self.manualEditingLinearRoadMarksLayer.startEditing()
            widthFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_WIDTH
            widthField = QgsField(widthFieldName, QVariant.String)
            catalogueFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_CATALOGUE_FILE
            catalogueField = QgsField(catalogueFieldName, QVariant.String)
            self.manualEditingLinearRoadMarksLayer.dataProvider().addAttributes([widthField, catalogueField])
            self.manualEditingLinearRoadMarksLayer.commitChanges()
            if self.manualEditingLinearRoadMarksLayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(self.manualEditingLinearRoadMarksLayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(self.manualEditingLinearRoadMarksLayer))
                self.manualEditingLinearRoadMarksLayer.loadNamedStyle(self.qmlManualEditingLinearRoadMarksFileName)
                # formConfig = manualEditingLinearRoadMarksLayer.editFormConfig()
                # formConfig.setReadOnly(0, True)
                # manualEditingLinearRoadMarksLayer.setEditFormConfig(formConfig)
                widthlistValues = {}
                # widthlistValues = {'0.1': 1, '0.15': 2}
                pos = 0
                for width in catalogueWidths:
                    widthlistValues[str(width)] = pos
                    pos = pos + 1
                self.field_to_value_map(self.manualEditingLinearRoadMarksLayer, widthFieldName, widthlistValues)
                listValues = {"kakita 1": 1, "kakita 2": 2}
                catalogueFilesListValues = {}
                pos = 0
                for catalogueFile in catalogueFileNames:
                    catalogueFilesListValues[catalogueFile] = pos
                    pos = pos + 1
                self.field_to_value_map(self.manualEditingLinearRoadMarksLayer, catalogueFieldName, catalogueFilesListValues)
                # widthFieldIndex = fields.indexFromName(field_name)
                self.manualEditingLinearRoadMarksLayer.triggerRepaint()
                self.iface.setActiveLayer(self.manualEditingLinearRoadMarksLayer)
                self.iface.zoomToActiveLayer()
                self.manualEditingLinearRoadMarksLayer.startEditing()
            else:
                self.manualEditingLinearRoadMarksLayer = None
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Impossible to Load table: " + layerManualEditingLinearRoadMarksTitle
                                   + " into QGIS")
                msgBox.exec_()
        layerManualEditingNonLinearRoadMarksTitle = MMTDefinitions.CONST_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_NAME
        layerList = QgsProject.instance().mapLayersByName(layerManualEditingNonLinearRoadMarksTitle)
        if not layerList:
            self.manualEditingNonLinearRoadMarksLayer = None
            self.manualEditingNonLinearRoadMarksLayer = QgsVectorLayer("Point?crs=" + projectCrs.authid(),
                                                               layerManualEditingNonLinearRoadMarksTitle, "memory")
            self.manualEditingNonLinearRoadMarksLayer.startEditing()
            roadMarkIdFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_FIELD_ROAD_MARK_ID
            roadMarkIdField = QgsField(roadMarkIdFieldName,QVariant.String)
            codeFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_FIELD_ROAD_MARK_CODE
            codeField = QgsField(codeFieldName,QVariant.String)
            typeFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_FIELD_ROAD_MARK_TYPE
            typeField = QgsField(typeFieldName,QVariant.String)
            catalogueFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_FIELD_CATALOGUE_FILE
            catalogueField = QgsField(catalogueFieldName,QVariant.String)
            self.manualEditingNonLinearRoadMarksLayer.dataProvider().addAttributes([roadMarkIdField, codeField, typeField, catalogueField])
            self.manualEditingNonLinearRoadMarksLayer.commitChanges()
            if self.manualEditingNonLinearRoadMarksLayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(self.manualEditingNonLinearRoadMarksLayer,False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(self.manualEditingNonLinearRoadMarksLayer))
                self.manualEditingNonLinearRoadMarksLayer.loadNamedStyle(self.qmlManualEditingNonLinearRoadMarksFileName)
                roadMarkIdlistValues = {}
                codelistValues = {}
                typelistValues = {}
                # widthlistValues = {'0.1': 1, '0.15': 2}
                pos = 0
                for roadMarkId in catalogueValuesById.keys():
                    roadMarkIdlistValues[str(roadMarkId)] = pos
                    code = catalogueValuesById[roadMarkId][MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_CODE]
                    type = catalogueValuesById[roadMarkId][MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_TYPE]
                    codelistValues[code] = pos
                    typelistValues[type] = pos
                    pos = pos + 1
                self.field_to_value_map(self.manualEditingNonLinearRoadMarksLayer, roadMarkIdFieldName, roadMarkIdlistValues)
                self.field_to_value_map(self.manualEditingNonLinearRoadMarksLayer, codeFieldName, codelistValues)
                self.field_to_value_map(self.manualEditingNonLinearRoadMarksLayer, typeFieldName, typelistValues)
                catalogueFilesListValues = {}
                pos = 0
                for catalogueFile in catalogueFileNames:
                    catalogueFilesListValues[catalogueFile] = pos
                    pos = pos + 1
                self.field_to_value_map(self.manualEditingNonLinearRoadMarksLayer, catalogueFieldName, catalogueFilesListValues)
                self.manualEditingNonLinearRoadMarksLayer.triggerRepaint()
                self.iface.setActiveLayer(self.manualEditingNonLinearRoadMarksLayer)
                self.iface.zoomToActiveLayer()
                self.manualEditingNonLinearRoadMarksLayer.startEditing()
            else:
                self.manualEditingNonLinearRoadMarksLayer = None
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Impossible to Load table: " + layerManualEditingNonLinearRoadMarksTitle
                                   + " into QGIS")
                msgBox.exec_()
        return

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def createProject(self):
        projectType = self.projectTypeComboBox.currentText()
        if projectType == MMTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project type")
            msgBox.exec_()
            return
        crs = self.projectQgsProjectionSelectionWidget.crs()
        isValidCrs = crs.isValid()
        crsAuthId = crs.authid()
        if not "EPSG:" in crsAuthId:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not EPSG")
            msgBox.exec_()
            return
        crsEpsgCode = int(crsAuthId.replace('EPSG:',''))
        crsOsr = osr.SpatialReference()  # define test1
        if crsOsr.ImportFromEPSG(crsEpsgCode) != 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error importing OSR CRS from EPSG code" + str(crsEpsgCode))
            msgBox.exec_()
            return
        if not crsOsr.IsProjected():
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not a projected CRS")
            msgBox.exec_()
            return
        altitudeIsMsl = True
        verticalCrsEpsgCode = -1
        if self.projVersionMajor < 8:
            if self.projectAltitudeEllipsoidRadioButton.isChecked():
                altitudeIsMsl = False
        else:
            verticalCrsStr = self.verticalCRSsComboBox.currentText()
            if not verticalCrsStr == MMTDefinitions.CONST_ELLIPSOID_HEIGHT:
                verticalCrsEpsgCode = int(verticalCrsStr.replace('EPSG:',''))
        dbFileName = self.databaseLineEdit.text()
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        strRoisShapefiles = ''
        cont = 0
        for roiShapefile in self.roisShapefiles:
            if cont > 0:
                strRoisShapefiles = strRoisShapefiles + self.parametersFromPythonStringSeparator
            strRoisShapefiles = strRoisShapefiles + roiShapefile
            cont = cont + 1
        if self.projVersionMajor < 8:
            ret = self.iPyProject.mmtCreateProject(dbFileName,
                                                   projectType,
                                                   crsEpsgCode,
                                                   altitudeIsMsl,
                                                   strRoisShapefiles)
        else:
            ret = self.iPyProject.mmtCreateProject(dbFileName,
                                                   projectType,
                                                   crsEpsgCode,
                                                   verticalCrsEpsgCode,
                                                   strRoisShapefiles)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        connectionName = QFileInfo(dbFileName).fileName()
        con = [connectionName, dbFileName]
        QSettings().setValue("SpatiaLite/connections/%s/sqlitepath" % (con[0]), con[1])
        self.iface.reloadConnections()
        self.getModelManagementSpatialiteConnections()
        msgBox = QMessageBox(self)
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(self.windowTitle)
        msgBox.setText("Process completed successfully")
        msgBox.exec_()
        return

    def getCommands(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtGetCommands(dbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        commands = []
        cont = 0
        for value in ret:
            if cont > 0:
                commands.append(value)
            cont = cont + 1
        self.processCommandComboBox.clear()
        self.processCommandComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for pointCloudCommand in commands:
            self.processCommandComboBox.addItem(pointCloudCommand)
        return

    def getModelManagementSpatialiteConnections(self):
        self.modelManagementConnections = {}
        settings = QSettings()
        settings.beginGroup('/SpatiaLite/connections')
        list_str_keys = settings.allKeys()
        paths = []
        for key in list_str_keys:
            if key!= 'selected':
                paths.append(settings.value(key))
        ret = self.iPyProject.getModelDbSpatialiteDbs(paths)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmTemporalPathLineEdit.setText("")
            self.projectManagerTemporalPath = None
            return
        connectionNames = settings.childGroups()
        cont = 0
        for connectionName in connectionNames:
            path = paths[cont]
            if path in ret:
                self.modelManagementConnections[connectionName] = paths[cont]
            cont = cont + 1
        self.projectsComboBox.clear()
        self.projectsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for connection in self.modelManagementConnections.keys():
            self.projectsComboBox.addItem(connection)
        return

    def getPhotogrammetrySpatialiteConnections(self):
        self.photogrammetryConnections = {}
        settings = QSettings()
        settings.beginGroup('/SpatiaLite/connections')
        list_str_keys = settings.allKeys()
        paths = []
        for key in list_str_keys:
            paths.append(settings.value(key))
        ret = self.iPyProject.getPhotogrammetrySpatialiteDbs(paths)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmTemporalPathLineEdit.setText("")
            self.projectManagerTemporalPath = None
            return
        connectionNames = settings.childGroups()
        cont = 0
        for connectionName in connectionNames:
            path = paths[cont]
            if path in ret:
                self.photogrammetryConnections[connectionName] = paths[cont]
            cont = cont + 1
        # self.pointCloudsComboBox.clear()
        # self.pointCloudsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        # for pointCloudConnection in self.pointCloudConnections.keys():
        #     self.pointCloudsComboBox.addItem(pointCloudConnection)
        # return

    def getPhotogrammetrySpatialiteConnectionsInProject(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        self.photogrammetryConnectionsInProject = {}
        ret = self.iPyProject.mmtGetPhotogrammetrySpatialiteDbsInProject(dbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.getPhotogrammetrySpatialiteConnections()
        for photogrammetryConnection in self.photogrammetryConnections.keys():
            path = self.photogrammetryConnections[photogrammetryConnection]
            if path in ret:
                self.photogrammetryConnectionsInProject[photogrammetryConnection] = path
        self.photogrammetriesComboBox.clear()
        self.photogrammetriesComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for photogrammetryConnectionInProject in self.photogrammetryConnectionsInProject.keys():
            self.photogrammetriesComboBox.addItem(photogrammetryConnectionInProject)
        return

    def getPointCloudsInProject(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        self.pointCloudsInProject = []
        ret = self.iPyProject.mmtGetPointCloudsInProject(dbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        # self.getPhotogrammetrySpatialiteConnections()
        # for photogrammetryConnection in self.photogrammetryConnections.keys():
        #     path = self.photogrammetryConnections[photogrammetryConnection]
        #     if path in ret:
        #         self.photogrammetryConnectionsInProject[photogrammetryConnection] = path
        cont = 0
        for value in ret:
            if cont > 0:
                self.pointCloudsInProject.append(value)
            cont = cont + 1
        self.pointCloudsComboBox.clear()
        self.pointCloudsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for pointCloudInProject in self.pointCloudsInProject:
            self.pointCloudsComboBox.addItem(pointCloudInProject)
        return


    # def getPointCloudConnections(self):
    #     self.pointCloudConnections = {}
    #     settings = QSettings()
    #     settings.beginGroup('/SpatiaLite/connections')
    #     list_str_keys = settings.allKeys()
    #     paths = []
    #     for key in list_str_keys:
    #         paths.append(settings.value(key))
    #     ret = self.iPyProject.getPointCloudSpatialiteDbs(paths)
    #     if ret[0] == "False":
    #         msgBox = QMessageBox(self)
    #         msgBox.setIcon(QMessageBox.Information)
    #         msgBox.setWindowTitle(self.windowTitle)
    #         msgBox.setText("Error:\n" + ret[1])
    #         msgBox.exec_()
    #         self.pmTemporalPathLineEdit.setText("")
    #         self.projectManagerTemporalPath = None
    #         return
    #     connectionNames = settings.childGroups()
    #     cont = 0
    #     for connectionName in connectionNames:
    #         path = paths[cont]
    #         if path in ret:
    #             self.pointCloudConnections[connectionName] = paths[cont]
    #         cont = cont + 1
    #     # self.pointCloudsComboBox.clear()
    #     # self.pointCloudsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
    #     # for pointCloudConnection in self.pointCloudConnections.keys():
    #     #     self.pointCloudsComboBox.addItem(pointCloudConnection)
    #     # return

    def initialize(self):
        self.num_format = re.compile(r'^\-?[1-9][0-9]*\.?[0-9]*')
        self.dbFileName = None
        self.layerTreeName = None
        self.layerTree = None
        self.projectType = None
        self.modelManagementConnections = {}
        # self.pointCloudConnections = {}
        self.pointCloudsInProject = []
        self.photogrammetryConnections = {}
        self.photogrammetryConnectionsInProject = {}
        self.windowTitle = MMTDefinitions.CONST_PROGRAM_NAME
        self.path = self.settings.value("last_path")
        if not self.path:
            self.path = QDir.currentPath()
            self.settings.setValue("last_path",self.path)
            self.settings.sync()

        self.projectManagerTemporalPath = self.settings.value("project_management_temporal_path")
        auxDir = QDir(self.path)
        if not self.projectManagerTemporalPath or not auxDir.exists(self.projectManagerTemporalPath):
            self.projectManagerTemporalPath = self.path_libCpp + MMTDefinitions.CONST_PROJECT_MANAGEMENT_TEMPORAL_PATH
            self.settings.setValue("project_management_temporal_path", self.projectManagerTemporalPath)
            self.settings.sync()
        self.pmTemporalPathLineEdit.setText(self.projectManagerTemporalPath)

        self.projectManagerOutputPath = self.settings.value("project_management_output_path")
        auxDir = QDir(self.path)
        if not self.projectManagerOutputPath or not auxDir.exists(self.projectManagerOutputPath):
            self.projectManagerOutputPath = self.path_libCpp + MMTDefinitions.CONST_PROJECT_MANAGEMENT_OUTPUT_PATH
            self.settings.setValue("project_management_output_path", self.projectManagerOutputPath)
            self.settings.sync()
        self.pmOutputPathLineEdit.setText(self.projectManagerOutputPath)

        qs = QSettings()
        spatialiteConnections = qs.value("SpatiaLite/connections")

        # template path que cuelga del directorio de este fichero
        pluginsPath = QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path()
        thisFilePath = os.path.dirname(os.path.realpath(__file__))
        thisFilePath = os.path.join(pluginsPath, thisFilePath)
        # templatePath = os.path.join(thisFilePath, PCTDefinitions.CONST_TEMPLATE_PATH)
        self.templatePath = thisFilePath + MMTDefinitions.CONST_TEMPLATE_PATH
        svg_paths = qs.value('svg/searchPathsForSVG')
        # if self.templatePath not in svg_paths:
            # qs.setValue('svg/searchPathsForSVG', svg_paths + [self.templatePath])
        qs.setValue('svg/searchPathsForSVG', self.templatePath)
        # if not svg_paths:
            # qs.setValue('svg/searchPathsForSVG', self.templatePath)
        # else:
            # qs.setValue('svg/searchPathsForSVG', svg_paths + [self.templatePath])

        self.qmlRoisFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_ROIS_TEMPLATE
        self.qmlRoadMarksFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_ROAD_MARKS_TEMPLATE
        self.qmlManualEditingLinearRoadMarksFileName = (self.templatePath
                                                        + MMTDefinitions.CONST_SYMBOLOGY_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_TEMPLATE)
        self.uiManualEditingLinearRoadMarksFileName = (self.templatePath
                                                        + MMTDefinitions.CONST_FORM_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_TEMPLATE)
        self.qmlManualEditingNonLinearRoadMarksFileName = (self.templatePath
                                                           + MMTDefinitions.CONST_SYMBOLOGY_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_TEMPLATE)
        # self.qmlPointCloudFileName = self.templatePath + PCTDefinitions.CONST_SYMBOLOGY_POINT_CLOUD_TEMPLATE
        ret = self.iPyProject.setModelDbManager()
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return

        ret = self.iPyProject.setPointCloudFileManager()
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return

        ret = self.iPyProject.setPhotogrammetryManager()
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return

        self.crsEpsgCode = -1
        self.verticalCrsEpsgCode = -1
        if self.projVersionMajor >=8:
            self.projectQgsProjectionSelectionWidget.crsChanged.connect(self.setCrs)
            self.projectQgsProjectionSelectionWidget.cleared.connect(self.setCrs)
            self.verticalCRSsComboBox.addItem(MMTDefinitions.CONST_ELLIPSOID_HEIGHT)
        self.projectQgsProjectionSelectionWidget.setCrs(QgsCoordinateReferenceSystem(MMTDefinitions.CONST_DEFAULT_CRS))

        # if self.projVersionMajor >=8:
        #     self.addPCFsQgsProjectionSelectionWidget.crsChanged.connect(self.setCrsAddPCFs)
        #     self.addPCFsQgsProjectionSelectionWidget.cleared.connect(self.setCrsAddPCFs)
        #     self.addPCFsVerticalCRSsComboBox.addItem(PCTDefinitions.CONST_ELLIPSOID_HEIGHT)
        # self.addPCFsQgsProjectionSelectionWidget.setCrs(QgsCoordinateReferenceSystem(PCTDefinitions.CONST_DEFAULT_CRS))
        #
        # if self.projVersionMajor >=8:
        #     self.ppToolsIPCFsQgsProjectionSelectionWidget.crsChanged.connect(self.setCrsPpToolsIPCFs)
        #     self.ppToolsIPCFsQgsProjectionSelectionWidget.cleared.connect(self.setCrsPpToolsIPCFs)
        #     self.ppToolsIPCFsVerticalCRSsComboBox.addItem(PCTDefinitions.CONST_ELLIPSOID_HEIGHT)
        # self.ppToolsIPCFsQgsProjectionSelectionWidget.setCrs(QgsCoordinateReferenceSystem(PCTDefinitions.CONST_DEFAULT_CRS))

        # self.iPyModelManagementToolsProject=IPyModelManagementToolsProject()
        # self.iPyModelManagementToolsProject.setPythonModulePath(libCppPath)
        # ret = self.iPyModelManagementToolsProject.initialize()
        self.parametersFromPythonStringSeparator = self.iPyProject.getParametersFromPythonStringSeparator()
        ret = self.iPyProject.mmtSetProjectManagerTemporalPath(self.projectManagerTemporalPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmTemporalPathLineEdit.setText("")
            self.projectManagerTemporalPath = None
            return
        ret = self.iPyProject.mmtSetProjectManagerOutputPath(self.projectManagerOutputPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmOutputPathLineEdit.setText("")
            self.projectManagerOutputPath = None
            return

        self.roisShapefiles = []
        self.roisFileTypes = []
        self.roisFileTypes.append(MMTDefinitions.CONST_DOCUMENTS_TYPE_SHAPEFILE)
        self.roisFilesActiveFileExtensions = self.roisFileTypes

        self.roadFiles = []
        self.roadFilesFileTypes = []
        self.roadFilesFileTypes.append(MMTDefinitions.CONST_DOCUMENTS_TYPE_SHAPEFILE)
        # self.powerLinesFilesFileTypes.append(PCTDefinitions.CONST_DOCUMENTS_TYPE_LAZFILE)
        self.roadFilesActiveFileExtensions = self.roadFilesFileTypes

        self.railwayFiles = []
        self.railwayFilesFileTypes = []
        self.railwayFilesFileTypes.append(MMTDefinitions.CONST_DOCUMENTS_TYPE_SHAPEFILE)
        # self.powerLinesFilesFileTypes.append(PCTDefinitions.CONST_DOCUMENTS_TYPE_LAZFILE)
        self.railwayFilesActiveFileExtensions = self.railwayFilesFileTypes

        self.breakwaterFiles = []
        self.breakwaterFilesFileTypes = []
        self.breakwaterFilesFileTypes.append(MMTDefinitions.CONST_DOCUMENTS_TYPE_SHAPEFILE)
        # self.powerLinesFilesFileTypes.append(PCTDefinitions.CONST_DOCUMENTS_TYPE_LAZFILE)
        self.breakwaterFilesActiveFileExtensions = self.breakwaterFilesFileTypes

        self.layerTreeProject = None
        self.layerTreeProjectName = None
        self.roadMarksVLayer = None
        # self.layerTreePCTiles = None
        # self.layerTreePCTilesName = None
        # self.loadedTiles = []
        # self.pvAnomaliesVLayer = None
        # self.pvAnomaliesPanelsVLayer = None

        # set projectManagement active
        self.modelManagementToolBox.setCurrentIndex(0)

        self.modelManagementToolBox.currentChanged.connect(self.onModelManagementToolBoxChanged)

        ###################################################
        # Project Management Page
        ###################################################

        # Projects spatialite databases
        self.getModelManagementSpatialiteConnections()
        self.projectsComboBox.currentIndexChanged.connect(self.selectProject)

        # Project
        self.openProjectPushButton.clicked.connect(self.openProject)
        self.closeProjectPushButton.clicked.connect(self.closeProject)

        self.projectManagementTabWidget.currentChanged.connect(self.onProjectManagementTabWidgetChanged)

        # Project types
        self.projecTypes = self.iPyProject.mmtGetProjectTypes()
        self.projectTypeComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for projectType in self.projecTypes:
            self.projectTypeComboBox.addItem(projectType)
        self.projectTypeComboBox.currentIndexChanged.connect(self.selectProjectType)

        # Parameters
        self.projectParametersPushButton.clicked.connect(self.selectProjectParameters)

        # DbFile
        self.databasePushButton.clicked.connect(self.selectNewDatabase)

        self.projectManagementTabWidget.setTabEnabled(0,True)
        self.projectManagementTabWidget.setTabEnabled(1,False)
        self.projectManagementTabWidget.setTabEnabled(2,False)
        self.projectManagementTabWidget.setTabEnabled(3,False)
        self.projectManagementTabWidget.setCurrentIndex(0)
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)

        # ROIs
        self.roisPushButton.clicked.connect(self.selectRois)
        self.numberOfRoisLineEdit.setText("0")

        # create
        self.createProjectPushButton.clicked.connect(self.createProject)

        # self.selectPLSFsPushButton.clicked.connect(self.selectPLSFs)
        # self.plsfNameShpRadioButton.clicked.connect(self.selectPLSFNameShp)
        # self.plsfNameInputRadioButton.clicked.connect(self.selectPLSFNameInput)
        # self.plsfNameFieldRadioButton.clicked.connect(self.selectPLSFNameField)
        # self.plsfNameInputPushButton.clicked.connect(self.selectPLSFNameInputValue)
        # self.plsfNameFieldPushButton.clicked.connect(self.selectPLSDNameFieldValue)

        # self.plsfElectricPylonsMinimumDistancePushButton.clicked.connect(self.selectMinimumDistanceBetweenElectricPylons)
        # self.plsfElectricPylonsBaseRadiusPushButton.clicked.connect(self.selectElectricPylonsBaseRadius)
        # self.plsfElectricPylonsHeightPushButton.clicked.connect(self.selectElectricPylonsHeight)

        # self.plsfProcessPushButton.clicked.connect(self.addPowerlinesFromShpProcess)
        #
        # self.selectSPSFsPushButton.clicked.connect(self.selectSPSFs)
        # self.spdSelectSFFieldsPushButton.clicked.connect(self.selectSPSFFields)
        # self.spsfProcessPushButton.clicked.connect(self.spsfProcess)

        # temporal path
        self.pmTemporalPathPushButton.clicked.connect(self.selectProjectManagerTemporalPath)
        self.pmOutputPathPushButton.clicked.connect(self.selectProjectManagerOutputPath)

        self.processingToolsPage.setEnabled(False)

        # ###################################################
        # # Processing ToolsPage
        # ###################################################
        self.addPointCloudPushButton.clicked.connect(self.addPointCloud)
        self.removePointCloudPushButton.clicked.connect(self.removePointCloud)
        self.openPointCloudPushButton.clicked.connect(self.openPointCloud)
        self.openPointCloudPushButton.setEnabled(False)
        self.pointCloudsComboBox.currentIndexChanged.connect(self.selectPointCloud)
        self.removePointCloudPushButton.setEnabled(False)
        #
        self.addPhotogrammetryPushButton.clicked.connect(self.addPhotogrammetryConnection)
        self.removePhotogrammetryPushButton.clicked.connect(self.removePhotogrammetryConnection)
        self.openPhotogrammetryPushButton.clicked.connect(self.openPhotogrammetry)
        self.openPhotogrammetryPushButton.setEnabled(False)
        self.photogrammetriesComboBox.currentIndexChanged.connect(self.selectPhotogrammetry)
        self.removePhotogrammetryPushButton.setEnabled(False)
        #
        self.processCommandComboBox.currentIndexChanged.connect(self.selectCommand)
        self.commandParamtersPushButton.clicked.connect(self.selectCommandParameters)
        self.processCommandPushButton.clicked.connect(self.selectCommandProcess)
        self.commandParamtersPushButton.setEnabled(False)
        self.processCommandPushButton.setEnabled(False)

        self.removeSelectedRoadMarksPushButton.clicked.connect(self.selectRemoveSelectedRoadMarks)
        self.saveLinearRoadMarksPushButton.clicked.connect(self.selectSaveManuallyEditedLinearRoadMarks)

        self.breakwaterCubesSelectRegionByRectangleToolButton.clicked.connect(self.selectBreakwaterCubesRegionByRectangle)
        self.breakwaterCubesSelectRegionByPolygonToolButton.clicked.connect(self.selectBreakwaterCubesRegionByPolygon)
        self.breakwaterCubesSelectRegionByRectangleToolButton.setEnabled(False)
        self.breakwaterCubesSelectRegionByPolygonToolButton.setEnabled(False)


        # self.reportGroupBox.setVisible(False)
        # self.reportGroupBox.setEnabled(False)
        # self.reportReferenceLayerComboBox.setFilters(QgsMapLayerProxyModel.RasterLayer)
        # self.reportReferenceLayerComboBox.layerChanged.connect(self.selectReportReferenceLayerComboBox)
        # self.reportSelectedFeatureCheckBox.stateChanged.connect(self.selectReportSelectedFeature)
        # # self.reportUpdatePushButton.clicked.connect(self.selectUpdateReferenceLayers)
        # self.reportArrayComboBox.currentIndexChanged.connect(self.selectReportArray)
        # self.reportMapPanelCheckBox.stateChanged.connect(self.selectMapPanelCheckBox)
        # self.reportPanelComboBox.currentIndexChanged.connect(self.selectReportPanel)
        # self.reportHotspotComboBox.currentIndexChanged.connect(self.selectReportHotspot)
        # self.reportProcessPushButton.clicked.connect(self.selectReportProcess)
        # self.mapPanel = self.reportMapPanelCheckBox.isChecked()

    def closeProject(self):
        if not self.dbFileName:
            return
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)
        # delete project in ram??
        root = QgsProject.instance().layerTreeRoot()
        self.removeGroup(root,self.layerTreeProjectName)
        self.dbFileName = None
        self.layerTreeProjectName = None
        self.layerTreeProject = None
        # self.layerTreePCTilesName = None
        # self.layerTreePCTiles = None
        self.projectsComboBox.setEnabled(True)
        self.projectsComboBox.setCurrentIndex(0)
        self.iface.mapCanvas().refresh()
        self.processingToolsPage.setEnabled(False)
        self.pointCloudsComboBox.clear()
        self.processCommandComboBox.clear()
        self.roadMarksVLayer = None
        self.manualEditingLinearRoadMarksLayer = None
        self.manualEditingNonLinearRoadMarksLayer = None

        # self.pvAnomaliesVLayer = None
        # self.pvAnomaliesPanelsVLayer = None
        return

    def loadRoadMarksLayer(self):
        self.roadMarksVLayer = None
        roadMarksTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(roadMarksTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = roadMarksTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = roadMarksTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer,False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlRoadMarksFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.roadMarksVLayer = vlayer
            # else: # cuando todavia no se han procesado road_marks
            #     msgBox = QMessageBox(self)
            #     msgBox.setIcon(QMessageBox.Information)
            #     msgBox.setWindowTitle(self.windowTitle)
            #     msgBox.setText("Impossible to Load table: " + roadMarksTableName
            #                        +" into QGIS")
            #     msgBox.exec_()

    def loadROIsLayer(self):
        roisTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROIS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(roisTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = roisTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROIS_TABLE_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = roisTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer,False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlRoisFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
            else:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Impossible to Load table: " + roisTableName
                                   +" into QGIS")
                msgBox.exec_()

    def onModelManagementToolBoxChanged(self,i): #changed!
        # QMessageBox.information(self,
        #           "Model Management ToolBox Changed!",
        #           "Current Tab Index: %d" % i ) #changed!
        if i==1: # Processing tools
            self.editingProcessesTabWidget.setTabEnabled(0, False)
            self.editingProcessesTabWidget.setTabEnabled(1, False)
            self.editingProcessesTabWidget.setTabEnabled(2, False)
            if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_BREAKWATER.lower():
                self.editingProcessesTabWidget.setTabEnabled(0, True)
                self.editingProcessesTabWidget.setCurrentIndex(0)
            elif self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_RAILWAY.lower():
                self.editingProcessesTabWidget.setTabEnabled(1, True)
                self.editingProcessesTabWidget.setCurrentIndex(1)
            elif self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_ROAD.lower():
                self.editingProcessesTabWidget.setTabEnabled(2, True)
                self.editingProcessesTabWidget.setCurrentIndex(2)
                self.saveNonLinearRoadMarksPushButton.setEnabled(False)
        return

    def onProjectManagementTabWidgetChanged(self,i): #changed!
        # QMessageBox.information(self,
        #           "Tab Index Changed!",
        #           "Current Tab Index: %d" % i ) #changed!
        # if i==1: # add powerlines
        #     self.plsfNameShpRadioButton.setChecked(True)
        #     self.plsfNameInputLineEdit.clear()
        #     self.plsfNameFieldLineEdit.clear()
        #     strValueMinimuDistance = MMTDefinitions.CONST_LINEAR_COARSE_PRECISION.format(MMTDefinitions.CONST_POWERLINES_MINIMUM_DISTANCE_BETWEEN_ELECTRIC_PYLONS_DEFAULT_VALUE)
        #     self.plsfElectricPylonsMinimumDistanceLineEdit.setText(strValueMinimuDistance)
        #     strValueBaseRadius = MMTDefinitions.CONST_LINEAR_COARSE_PRECISION.format(MMTDefinitions.CONST_POWERLINES_ELECTRIC_PYLONS_BASE_RADIUS_DEFAULT_VALUE)
        #     self.plsfElectricPylonsBaseRadiusLineEdit.setText(strValueBaseRadius)
        #     strValueHeight = MMTDefinitions.CONST_LINEAR_COARSE_PRECISION.format(MMTDefinitions.CONST_POWERLINES_ELECTRIC_PYLONS_HEIGHT_DEFAULT_VALUE)
        #     self.plsfElectricPylonsHeightLineEdit.setText(strValueHeight)
        return

    def openPhotogrammetry(self):
        return

    def openPointCloud(self):
        return

    def openProject(self):
        self.closeProjectPushButton.setEnabled(False)
        self.dbFileName = None
        self.layerTreeName = None
        self.layerTree = None
        self.roadMarksVLayer = None
        self.manualEditingLinearRoadMarksLayer = None
        self.manualEditingNonLinearRoadMarksLayer = None
        connectionFileName = self.projectsComboBox.currentText()
        if connectionFileName == MMTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project before")
            msgBox.exec_()
            return
        connectionPath = self.modelManagementConnections[connectionFileName]
        ret = self.iPyProject.mmtOpenProject(connectionPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        if self.projVersionMajor < 8:
            ret = self.iPyProject.mmtGetProjectCrsEpsgCode(connectionPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n"+ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            self.crsEpsgCode = ret[1]
            strCrsEpsgCode = MMTDefinitions.CONST_EPSG_PREFIX + str(self.crsEpsgCode)
        else:
            ret = self.iPyProject.mmtGetProjectCrsEpsgCodes(connectionPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n"+ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            self.crsEpsgCode = ret[1]
            strCrsEpsgCode = MMTDefinitions.CONST_EPSG_PREFIX + str(self.crsEpsgCode)
            self.projectQgsProjectionSelectionWidget.setCrs(QgsCoordinateReferenceSystem(strCrsEpsgCode))
            self.verticalCrsEpsgCode = ret[2]
            #
            # self.addPCFsQgsProjectionSelectionWidget.setCrs(
            #     QgsCoordinateReferenceSystem(strCrsEpsgCode))
            # # self.addPCFsQgsProjectionSelectionWidget.setCrs(
            # #     QgsCoordinateReferenceSystem(qLidarDefinitions.CONST_DEFAULT_CRS))
            # self.setCrsAddPCFs()
            self.verticalCRSsComboBox.setCurrentIndex(0)
            if self.verticalCrsEpsgCode != -1:
                strVerticalCrsEpsgCode = MMTDefinitions.CONST_EPSG_PREFIX + str(self.verticalCrsEpsgCode)
                index = self.verticalCRSsComboBox.findText(strVerticalCrsEpsgCode, Qt.MatchFixedString)
                if index != -1:
                    self.verticalCRSsComboBox.setCurrentIndex(index)
        # establecer el crs del proyecto de qgis si no coincide con el del proyecto del plugin
        qgisProjectCrsAsEpsg = QgsProject.instance().crs().authid()
        if qgisProjectCrsAsEpsg.lower() != strCrsEpsgCode:
            projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(self.crsEpsgCode)
            QgsProject.instance().setCrs(projectCrs)
        ret = self.iPyProject.mmtGetProjectType(connectionPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        self.projectType = ret[1]
        self.dbFileName = connectionPath
        groupName = MMTDefinitions.CONST_LAYER_TREE_PROJECT_NAME
        self.layerTreeProjectName = groupName + connectionFileName
        root = QgsProject.instance().layerTreeRoot()
        self.layerTreeProject = root.addGroup(self.layerTreeProjectName)
        self.loadROIsLayer()
        if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_ROAD.lower():
            self.loadRoadMarksLayer()
            self.addVirtualRoadMarksLayers()
        # if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_SOLARPARK.lower():
        #     self.loadPhotovoltaicArrayPanels()
        #     self.loadPhotovoltaicPanels()
        #     self.loadPhotovoltaicAnomaliesLayers()
        # self.loadTilesLayer()
        self.closeProjectPushButton.setEnabled(True)
        self.openProjectPushButton.setEnabled(False)
        self.projectsComboBox.setEnabled(False)
        self.projectManagementTabWidget.setEnabled(True)
        self.projectManagementTabWidget.setTabEnabled(0, False)
        # if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_POWERLINE.lower():
        #     self.projectManagementTabWidget.setTabEnabled(1, True)
        #     self.projectManagementTabWidget.setTabEnabled(2, False)
        #     self.plsfNameShpRadioButton.setChecked(True)
        #     self.selectPLSFNameShp()
        # if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_SOLARPARK.lower():
        #     self.projectManagementTabWidget.setTabEnabled(1, False)
        #     self.projectManagementTabWidget.setTabEnabled(2, True)
        #     self.spdSelectSFFieldsPushButton.setEnabled(False)
        #     self.spsfProcessPushButton.setEnabled(False)
        # # tilesTableName = PCTDefinitions.CONST_SPATIALITE_LAYERS_TILES_TABLE_NAME
        # # layerList = QgsProject.instance().mapLayersByName(tilesTableName)
        # # if not layerList:
        # #     self.projectManagementTabWidget.setTabEnabled(2, False)
        # # else:
        # #     tilesLayer = layerList[0]
        # #     if tilesLayer.featureCount() > 0:
        # #         self.projectManagementTabWidget.setTabEnabled(2, True)

        self.processingToolsPage.setEnabled(True)
        self.getPointCloudsInProject()
        self.getPhotogrammetrySpatialiteConnectionsInProject()
        self.getCommands()
        # # msgBox = QMessageBox(self)
        # # msgBox.setIcon(QMessageBox.Information)
        # # msgBox.setWindowTitle(self.windowTitle)
        # # msgBox.setText("Process completed successfully")
        # # msgBox.exec_()

        ret = self.iPyProject.mmtSetProjectManagerTemporalPath(self.projectManagerTemporalPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtSetProjectManagerOutputPath(self.projectManagerOutputPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.modelManagementToolBox.setCurrentIndex(1)

    def processCubesForRegion(self):
        segmentCubes = self.breakwaterSegmentCubesRadioButton.isChecked()
        removeCubes = self.breakwaterRemoveCubesRadioButton.isChecked()
        wktGeom = None
        if self.toolRectangle:
            wktGeom = self.toolRectangle.getWktGeomeetry()
            self.toolRectangle.endSelection.disconnect(self.processCubesForRegion)
            self.toolRectangle.rubberBand.hide()
            self.toolRectangle = None
            self.iface.mapCanvas().unsetMapTool(self.toolRectangle)
            self.breakwaterCubesSelectRegionByRectangleToolButton.setChecked(False)
        elif self.toolPolygon:
            wktGeom = self.toolPolygon.getWktGeomeetry()
            self.toolPolygon.endSelection.disconnect(self.processCubesForRegion)
            self.toolPolygon.rubberBand.hide()
            self.toolPolygon.rubberBand.reset(QgsWkbTypes.PolygonGeometry)
            self.toolPolygon.reset()
            self.toolPolygon = None
            self.iface.mapCanvas().unsetMapTool(self.toolPolygon)
            self.breakwaterCubesSelectRegionByPolygonToolButton.setChecked(False)
        if not wktGeom:
            return
        text = "It will proceed to "
        if segmentCubes:
            text += "segment cubes"
        text += "\nfor the selected region"
        text += "\nThis process will update the project database"
        text += "\n\nDo you wish continue?"
        reply = QMessageBox.question(self.iface.mainWindow(), self.windowTitle,
                                     text, QMessageBox.Yes, QMessageBox.No)
        if reply == QMessageBox.Yes:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process finished:\n")
            msgBox.exec_()
            return
        else:
            return
        projectCrs = QgsProject.instance().crs()
        projectCrsEpsgCode = -1
        projectCrsProj4 = ""
        projectCrsAuthId = projectCrs.authid()
        if "EPSG" in projectCrsAuthId:
            projectCrsEpsgCode = int(projectCrsAuthId.replace("EPSG:", ""))
        projectCrsProj4 = projectCrs.toProj4()

        # ret = self.iPyProject.pctGetTilesFromWktGeometry(self.projectPath,
        #                                                  wktGeom,
        #                                                  projectCrsEpsgCode,
        #                                                  projectCrsProj4)
        # if ret[0] == "False":
        #     msgBox = QMessageBox(self)
        #     msgBox.setIcon(QMessageBox.Information)
        #     msgBox.setWindowTitle(self.windowTitle)
        #     msgBox.setText("Error:\n" + ret[1])
        #     msgBox.exec_()
        #     return
        yo = 1

        return

    def refreshMapCanvas(self):
        currentScale = self.iface.mapCanvas().scale()
        newScale = currentScale * 1.001
        self.iface.mapCanvas().zoomScale(newScale)

    def removeGroup(self,root,name):
        # root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(name)
        if not group is None:
            for child in group.children():
                dump = child.dump()
                id = dump.split("=")[-1].strip()
                QgsProject.instance().removeMapLayer(id)
            root.removeChildNode(group)

    def removePhotogrammetryConnection(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        selectedPhotogrammetryConnectionInProject = self.photogrammetriesComboBox.currentText()
        if selectedPhotogrammetryConnectionInProject == MMTDefinitions.CONST_NO_COMBO_SELECT:
            return
        photogrammetrySpatialiteDbFileName = self.photogrammetryConnectionsInProject[selectedPhotogrammetryConnectionInProject]
        ret = self.iPyProject.mmtRemovePhotogrammetryDb(dbFileName,
                                                        photogrammetrySpatialiteDbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        else:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process completed successfully")
            msgBox.exec_()
        del self.photogrammetryConnectionsInProject[selectedPhotogrammetryConnectionInProject]
        self.photogrammetriesComboBox.clear()
        self.photogrammetriesComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for photogrammetryConnectionInProject in self.photogrammetryConnectionsInProject.keys():
            self.photogrammetriesComboBox.addItem(photogrammetryConnectionInProject)
        return

    def removePointCloud(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        selectedPointCloudInProject = self.pointCloudsComboBox.currentText()
        if selectedPointCloudInProject == MMTDefinitions.CONST_NO_COMBO_SELECT:
            return
        ret = self.iPyProject.mmtRemovePointCloud(dbFileName,
                                                  selectedPointCloudInProject)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        else:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process completed successfully")
            msgBox.exec_()
        self.pointCloudsInProject.remove(selectedPointCloudInProject)
        self.pointCloudsComboBox.clear()
        self.pointCloudsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for pointCloud in self.pointCloudsInProject:
            self.pointCloudsComboBox.addItem(pointCloud)
        return

    def selectBreakwaterCubesRegionByPolygon(self):
        return

    def selectBreakwaterCubesRegionByRectangle(self):
        self.breakwaterCubesSelectRegionByRectangleToolButton.setChecked(True)
        self.breakwaterCubesSelectRegionByPolygonToolButton.setChecked(False)
        self.toolRectangle = None
        self.toolPolygon = None
        self.toolRectangle = RectangleMapTool(self.iface.mapCanvas())
        self.iface.mapCanvas().setMapTool(self.toolRectangle)
        self.toolRectangle.endSelection.connect(self.processCubesForRegion)
        return

    def selectCommand(self):
        self.breakwaterCubesSelectRegionByRectangleToolButton.setEnabled(False)
        self.breakwaterCubesSelectRegionByPolygonToolButton.setEnabled(False)
        if self.projectsComboBox.currentText() == MMTDefinitions.CONST_NO_COMBO_SELECT:
            return
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        # self.reportGroupBox.setVisible(False)
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            self.processCommandPushButton.setEnabled(False)
            return
        command = self.processCommandComboBox.currentText()
        if command == MMTDefinitions.CONST_NO_COMBO_SELECT:
            self.processCommandPushButton.setEnabled(False)
            self.commandParamtersPushButton.setEnabled(False)
            return
        # processCommandIsEnabled = self.iPyProject.mmtGetEnabledProcessCommand(command)
        # self.processCommandPushButton.setEnabled(processCommandIsEnabled)
        self.commandParamtersPushButton.setEnabled(True)
        self.processCommandPushButton.setEnabled(True)
        if (command == MMTDefinitions.CONST_MODELBREAKWATERDEFINITIONS_COMMAND_CSSHP
                or command == MMTDefinitions.CONST_MODELBREAKWATERDEFINITIONS_COMMAND_RCSHP):
            self.breakwaterCubesSelectRegionByRectangleToolButton.setEnabled(True)
            self.breakwaterCubesSelectRegionByPolygonToolButton.setEnabled(True)

    def selectCommandParameters(self):
        command = self.processCommandComboBox.currentText()
        if command == MMTDefinitions.CONST_NO_COMBO_SELECT:
            return
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtSelectCommandParameters(dbFileName, command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        return

    def selectCommandProcess(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        command = self.processCommandComboBox.currentText()
        if command == MMTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select command to process")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtGetCommandNeedsPointCloudDb(dbFileName, command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        needsPointCloudDb = False
        strNeeds = ret[1]
        strNeeds = strNeeds.lower()
        if strNeeds == "true":
            needsPointCloudDb = True
        ret = self.iPyProject.mmtGetCommandNeedsPhotogrammetryDb(dbFileName, command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        needsPhotogrammetryDb = False
        strNeeds = ret[1]
        strNeeds = strNeeds.lower()
        if strNeeds == "true":
            needsPhotogrammetryDb = True
        pointCloudPath = ""
        photogrammetrySpatialiteDbFileName = ""
        if needsPointCloudDb:
            pointCloudPath = self.pointCloudsComboBox.currentText()
            if pointCloudPath == MMTDefinitions.CONST_NO_COMBO_SELECT:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Select Point Cloud Project")
                msgBox.exec_()
                return
        if needsPhotogrammetryDb:
            selectedPhotogrammetryInProject = self.photogrammetriesComboBox.currentText()
            if selectedPhotogrammetryInProject == MMTDefinitions.CONST_NO_COMBO_SELECT:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Select Photogrammetry Project")
                msgBox.exec_()
                return
            photogrammetrySpatialiteDbFileName = self.photogrammetryConnectionsInProject[selectedPhotogrammetryInProject]
        initialDateTime = QDateTime.currentDateTime()
        ret = self.iPyProject.mmtProcessCommand(dbFileName,
                                                command,
                                                pointCloudPath,
                                                photogrammetrySpatialiteDbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return

        finalDateTime = QDateTime.currentDateTime()
        initialSeconds = initialDateTime.toTime_t()
        finalSeconds = finalDateTime.toTime_t()
        totalDurationSeconds = finalSeconds - initialSeconds
        durationDays = floor(totalDurationSeconds / 60.0 / 60.0 / 24.0)
        durationHours = floor((totalDurationSeconds - durationDays * 60.0 * 60.0 * 24.0) / 60.0 / 60.0)
        durationMinutes = floor(
            (totalDurationSeconds - durationDays * 60.0 * 60.0 * 24.0 - durationHours * 60.0 * 60.0) / 60.0)
        durationSeconds = totalDurationSeconds - durationDays * 60.0 * 60.0 * 24.0 - durationHours * 60.0 * 60.0 - durationMinutes * 60.0
        msgTtime = "- Process time:\n"
        msgTtime += "  - Start time of the process ......................: "
        msgTtime += initialDateTime.toString("yyyy/MM/dd - hh/mm/ss.zzz")
        msgTtime += "\n"
        msgTtime += "  - End time of the process ........................: "
        msgTtime += finalDateTime.toString("yyyy/MM/dd - hh/mm/ss.zzz")
        msgTtime += "\n"
        msgTtime += "  - Number of total seconds ........................: "
        msgTtime += f"{totalDurationSeconds:.3f}"  # QString.number(totalDurationSeconds, 'f', 3)
        msgTtime += "\n"
        msgTtime += "    - Number of days ...............................: "
        msgTtime += str(durationDays)  # QString.number(durationDays)
        msgTtime += "\n"
        msgTtime += "    - Number of hours ..............................: "
        msgTtime += str(durationHours)  # QString.number(durationHours)
        msgTtime += "\n"
        msgTtime += "    - Number of minutes ............................: "
        msgTtime += str(durationMinutes)  # QString.number(durationMinutes)
        msgTtime += "\n"
        msgTtime += "    - Number of seconds ............................: "
        msgTtime += f"{durationSeconds:.3f}"  # QString.number(durationSeconds, 'f', 3)
        msgTtime += "\n"
        msg = "Process completed successfully"
        msg += "\n"
        msg += msgTtime
        msgBox = QMessageBox(self)
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(self.windowTitle)
        msgBox.setText(msg)
        msgBox.exec_()

        if ret[1] == "True": #needReloadProject:
            msg = "Before the next step, QGis and the Project must be reopened "
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText(msg)
            msgBox.exec_()

        # if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_POWERLINE.lower():
        #     self.loadHazardAreasMshLayer()
        #     self.loadHazardAreasLayer()
        # if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_SOLARPARK.lower():
        #     self.loadPhotovoltaicArrayPanels()
        #     self.loadPhotovoltaicPanels()
        #     self.loadPhotovoltaicAnomaliesLayers()
        self.refreshMapCanvas()
        return

    def selectNewDatabase(self):
        oldFileName=self.databaseLineEdit.text()
        title="Select New Project File (.sqlite)"
        filters="Project Files (*.sqlite)"
        fileName, _ = QFileDialog.getSaveFileName(self,title,self.path,filters)
        if fileName:
            fileInfo = QFileInfo(fileName)
            self.path = fileInfo.absolutePath()
            self.databaseLineEdit.setText(fileName)
            self.settings.setValue("last_path", self.path)
            self.settings.sync()
        return

    def selectPhotogrammetry(self):
        self.openPhotogrammetryPushButton.setEnabled(False)
        self.removePhotogrammetryPushButton.setEnabled(False)
        photogrammetry = self.photogrammetriesComboBox.currentText()
        if photogrammetry != MMTDefinitions.CONST_NO_COMBO_SELECT:
            self.removePhotogrammetryPushButton.setEnabled(True)

    def selectPointCloud(self):
        self.openPointCloudPushButton.setEnabled(False)
        self.removePointCloudPushButton.setEnabled(False)
        pointCloud = self.pointCloudsComboBox.currentText()
        if pointCloud != MMTDefinitions.CONST_NO_COMBO_SELECT:
            self.removePointCloudPushButton.setEnabled(True)

    def selectProject(self):
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)
        projectFileName = self.projectsComboBox.currentText()
        if projectFileName == MMTDefinitions.CONST_NO_COMBO_SELECT:
            self.projectManagementTabWidget.setEnabled(True)
            self.projectManagementTabWidget.setTabEnabled(0, True)
            self.projectManagementTabWidget.setTabEnabled(1, False)
            self.projectManagementTabWidget.setTabEnabled(2, False)
            self.projectManagementTabWidget.setCurrentIndex(0)
            if self.dbFileName:
                self.closeProject()
        else:
            self.projectManagementTabWidget.setEnabled(False)
            # self.projectManagementTabWidget.setTabEnabled(0, False)
            # self.projectManagementTabWidget.setTabEnabled(1, False)
            # self.projectManagementTabWidget.setTabEnabled(2, False)
            self.projectManagementTabWidget.setCurrentIndex(1)
            self.openProjectPushButton.setEnabled(True)
            self.closeProjectPushButton.setEnabled(False)
        return

    def selectProjectManagerOutputPath(self):
        strDir = QFileDialog.getExistingDirectory(self, "Select directory", self.projectManagerOutputPath,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            ret = self.iPyProject.mmtSetProjectManagerOutputPath(strDir)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.pmOutputPathLineEdit.setText("")
                self.projectManagerOutputPath = None
                return
            self.projectManagerOutputPath = strDir
            self.settings.setValue("project_management_output_path", self.projectManagerOutputPath)
            self.settings.sync()
            self.pmOutputPathLineEdit.setText(strDir)
        return

    def selectProjectManagerTemporalPath(self):
        strDir = QFileDialog.getExistingDirectory(self,"Select directory", self.projectManagerTemporalPath,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            ret = self.iPyProject.mmtSetProjectManagerTemporalPath(strDir)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.pmTemporalPathLineEdit.setText("")
                self.projectManagerTemporalPath = None
                return
            self.projectManagerTemporalPath = strDir
            self.settings.setValue("project_management_temporal_path", self.projectManagerTemporalPath)
            self.settings.sync()
            self.pmTemporalPathLineEdit.setText(strDir)
        return

    def selectProjectParameters(self):
        projectType = self.projectTypeComboBox.currentText()
        if projectType == MMTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project type before")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtSelectProjectParameters(projectType)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        return

    def selectProjectType(self):
        projectType = self.projectTypeComboBox.currentText()
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Project type: "+projectType)
        # msgBox.exec_()
        return

    def selectRemoveSelectedRoadMarks(self):
        if not self.roadMarksVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Road marks Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelectedRoadMarks = self.roadMarksVLayer.selectedFeatureCount()
        if numberOfSelectedRoadMarks < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from road marks layer")
            msgBox.exec_()
            return
        road_marks_ids_to_remove = []
        fieldIdIdx = self.roadMarksVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_FIELD_ID)
        str_ids = ''
        for i in range(numberOfSelectedRoadMarks):
            roadMarkFeature = self.roadMarksVLayer.selectedFeatures()[i]
            roadMarkId = roadMarkFeature.attributes()[fieldIdIdx]
            road_marks_ids_to_remove.append(roadMarkId)
            str_ids = str_ids + str(roadMarkId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtRemoveRoadMarks(dbFileName, road_marks_ids_to_remove)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        self.roadMarksVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectRois(self):
        previousFiles = self.roisShapefiles[:] # copia desligada
        dlg = MultipleFileSelectorDialog(self.iface,
                                         self.path,
                                         MMTDefinitions.CONST_SELECT_ROIS_SHAPEFILES_DIALOG_TITLE,
                                         self.roisFileTypes,
                                         self.roisShapefiles,
                                         self.roisFilesActiveFileExtensions)
        dlg.show() # show the dialog
        result = dlg.exec_() # Run the dialog
        self.path = dlg.getPath()
        self.settings.setValue("last_path",self.path)
        files = dlg.getFiles() # los hay repetidos
        self.roisShapefiles = []
        self.numberOfRoisLineEdit.setText("0")
        for file in files:
            fileBaseName = QFileInfo(file).baseName()
            findFile = False
            for roiFile in self.roisShapefiles:
                if fileBaseName == QFileInfo(roiFile).baseName():
                    findFile = True
                    break
            if not findFile:
                self.roisShapefiles.append(file)
        self.roisFilesActiveFileExtensions = dlg.getActiveFileExtensions()
        self.numberOfRoisLineEdit.setText(str(len(self.roisShapefiles)))
        return

    def selectSaveManuallyEditedLinearRoadMarks(self):
        if not self.manualEditingLinearRoadMarksLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Invalid layer for manually editid linear road marks")
            msgBox.exec_()
            return
        numberOfFeatures = self.manualEditingLinearRoadMarksLayer.featureCount()
        if numberOfFeatures < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Edit some feature in layer " + self.manualEditingLinearRoadMarksLayer.name())
            msgBox.exec_()
            return
        widths = []
        standarRoadMarksFileNames = []
        wktGeometries = []
        widthsIdx = (self.manualEditingLinearRoadMarksLayer.
                   fields().indexFromName(MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_WIDTH))
        # widthsDictionary = self.manualEditingLinearRoadMarksLayer.editorWidgetSetup(widthsIdx).config().values()
        widths_key_list = list(self.manualEditingLinearRoadMarksLayer.
                               editorWidgetSetup(widthsIdx).config()['map'].keys())
        widths_val_list = list(self.manualEditingLinearRoadMarksLayer.
                               editorWidgetSetup(widthsIdx).config()['map'].values())
        standarRoadMarksFileNamesIdx = (self.manualEditingLinearRoadMarksLayer.fields().indexFromName(
            MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_CATALOGUE_FILE))
        # standarRoadMarksFileNamesDictionary = (self.manualEditingLinearRoadMarksLayer.
        #                                        editorWidgetSetup(standarRoadMarksFileNamesIdx).config().values())
        standarRoadMarksFileNames_key_list = list(self.manualEditingLinearRoadMarksLayer.
                                               editorWidgetSetup(standarRoadMarksFileNamesIdx).config()['map'].keys())
        standarRoadMarksFileNames_val_list = list(self.manualEditingLinearRoadMarksLayer.
                                               editorWidgetSetup(standarRoadMarksFileNamesIdx).config()['map'].values())
        for feature in self.manualEditingLinearRoadMarksLayer.getFeatures():
            wktGeometry = feature.geometry().asWkt()
            widthDictIndex = feature[MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_WIDTH]
            width = -1
            if not widthDictIndex == NULL:
                position = widths_val_list.index(widthDictIndex)
                if position > -1:
                    width = float(widths_key_list[position])
            standarRoadMarkFileNameDictIndex = feature[
                MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_CATALOGUE_FILE]
            standarRoadMarkFileName = ''
            if not standarRoadMarkFileNameDictIndex == NULL:
                position = standarRoadMarksFileNames_val_list.index(standarRoadMarkFileNameDictIndex)
                if position > -1:
                    standarRoadMarkFileName = standarRoadMarksFileNames_key_list[position]
            if width > 0:
                widths.append(width)
                standarRoadMarksFileNames.append(standarRoadMarkFileName)
                wktGeometries.append(wktGeometry)
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtSaveManuallyEditedLinearRoadMarks(dbFileName,
                                                                   widths,
                                                                   standarRoadMarksFileNames,
                                                                   wktGeometries)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            return
        self.manualEditingLinearRoadMarksLayer.startEditing()
        for feature in self.manualEditingLinearRoadMarksLayer.getFeatures():
            self.manualEditingLinearRoadMarksLayer.deleteFeature(feature.id())
        self.manualEditingLinearRoadMarksLayer.commitChanges()
        self.roadMarksVLayer.triggerRepaint()
        self.manualEditingLinearRoadMarksLayer.startEditing()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def setCrs(self):
        crs = self.projectQgsProjectionSelectionWidget.crs()
        isValidCrs = crs.isValid()
        crsAuthId = crs.authid()
        if not "EPSG:" in crsAuthId:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not EPSG")
            msgBox.exec_()
            self.projectQgsProjectionSelectionWidget.setCrs(
                QgsCoordinateReferenceSystem(MMTDefinitions.CONST_DEFAULT_CRS))
            return
        crsEpsgCode = int(crsAuthId.replace('EPSG:',''))
        crsOsr = osr.SpatialReference()  # define test1
        if crsOsr.ImportFromEPSG(crsEpsgCode) != 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error importing OSR CRS from EPSG code" + str(crsEpsgCode))
            msgBox.exec_()
            self.projectQgsProjectionSelectionWidget.setCrs(
                QgsCoordinateReferenceSystem(MMTDefinitions.CONST_DEFAULT_CRS))
            return
        if not crsOsr.IsProjected():
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not a projected CRS")
            msgBox.exec_()
            self.projectQgsProjectionSelectionWidget.setCrs(
                QgsCoordinateReferenceSystem(MMTDefinitions.CONST_DEFAULT_CRS))
            return
        self.setVerticalCRSs(crsEpsgCode)
        crsEpsgCodeString = 'EPSG:'+str(crsEpsgCode)
        # self.addPCFsQgsProjectionSelectionWidget.setCrs(
        #     QgsCoordinateReferenceSystem(crsEpsgCodeString))
        self.crsEpsgCode = crsEpsgCode

    def setVerticalCRSs(self,crsEpsgCode):
        self.verticalCRSsComboBox.clear()
        self.verticalCRSsComboBox.addItem(MMTDefinitions.CONST_ELLIPSOID_HEIGHT)
        ret = self.iPyProject.mmtGetVerticalCRSs(crsEpsgCode)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n"+ret[1])
            msgBox.exec_()
            # self.projectsComboBox.setCurrentIndex(0)
            return
        else:
            cont = 0
            for value in ret:
                if cont > 0:
                    # strCrs = qLidarDefinitions.CONST_EPSG_PREFIX + str(value)
                    self.verticalCRSsComboBox.addItem(value)
                cont = cont + 1
            # msgBox = QMessageBox(self)
            # msgBox.setIcon(QMessageBox.Information)
            # msgBox.setWindowTitle(self.windowTitle)
            # msgBox.setText("Process completed successfully")
            # msgBox.exec_()
        strCrs = MMTDefinitions.CONST_EPSG_PREFIX + str(crsEpsgCode)
        if strCrs == MMTDefinitions.CONST_DEFAULT_CRS:
            index = self.verticalCRSsComboBox.findText(MMTDefinitions.CONST_DEFAULT_VERTICAL_CRS)#, QtCore.Qt.MatchFixedString)
            if index > 0:
                self.verticalCRSsComboBox.setCurrentIndex(index)
        return
