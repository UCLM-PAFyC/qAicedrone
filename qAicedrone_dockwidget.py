# -*- coding: utf-8 -*-
"""
/***************************************************************************
 qAicedroneDockWidget
                                 A QGIS plugin
 A plugin for AICEDRONE project
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-06-13
        git sha              : $Format:%H$
        copyright            : (C) 2019 by David Hernandez Lopez, Universidad de Castilla-La Mancha
        email                : david.hernandez@uclm.es
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

# dhl
import sys, os
from .resources_rc import *
from osgeo import osr
from decimal import Decimal
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, QFileInfo, QDir, QObject
from PyQt5.QtWidgets import QMessageBox, QFileDialog, QTabWidget, QInputDialog, QLineEdit
from PyQt5.QtWidgets import QDockWidget
from qgis.core import QgsApplication, QgsDataSourceUri, QgsProject, QgsCoordinateReferenceSystem
from qgis.core import QgsProject, QgsVectorLayer, QgsSymbol, QgsRendererCategory, QgsCategorizedSymbolRenderer

# pluginsPath = QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path()
# pluginPath = os.path.dirname(os.path.realpath(__file__))
# pluginPath = os.path.join(pluginsPath, pluginPath)
# libCppPath = os.path.join(pluginPath, 'libCpp')
# existsPluginPath = QDir(libCppPath).exists()
# sys.path.append(pluginPath)
# sys.path.append(libCppPath)
# os.environ["PATH"] += os.pathsep + libCppPath
# from libCpp.libPyModelManagementTools import IPyModelManagementToolsProject
from .multipleFileSelectorDialog.multiple_file_selector_dialog import *  # panel nueva camara
# from .reports.Report import *
# import MMTDefinitions
from . import MMTDefinitions
from .selectionMapTools.rectangle_map_tool import RectangleMapTool
from .selectionMapTools.polygon_map_tool import PolygonMapTool

#  dhl

import os

from math import floor
import re

from PyQt5 import QtGui, QtWidgets, uic
from PyQt5.QtCore import pyqtSignal

from qgis import utils

from qgis.core import Qgis

qgis_version_number_str = Qgis.QGIS_VERSION.split('-')[0]
qgis_version_first_number = int(qgis_version_number_str.split('.')[0])
qgis_version_second_number = int(qgis_version_number_str.split('.')[1])
qgis_version_third_number = int(qgis_version_number_str.split('.')[2])
qgis_version_second_number_change_buffer_parameters = 20

from osgeo import osr

projVersionMajor = osr.GetPROJVersionMajor()

FORM_CLASS = None

# if projVersionMajor < 8:
#     FORM_CLASS, _ = uic.loadUiType(os.path.join(
#         os.path.dirname(__file__), 'model_management_tools_dockwidget_base_old_osgeo.ui'))
# else:
#     FORM_CLASS, _ = uic.loadUiType(os.path.join(
#         os.path.dirname(__file__), 'model_management_tools_dockwidget_base.ui'))
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'qAicedrone_dockwidget_base.ui'))


class qAicedroneDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self,
                 iface,
                 projVersionMajor,
                 pluginPath,
                 libCppPath,
                 currentPluginName,
                 settings,
                 iPyProject,
                 parent=None):
        """Constructor."""
        super(qAicedroneDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setWindowTitle(MMTDefinitions.CONST_PROGRAM_NAME)
        self.iface = iface
        self.projVersionMajor = projVersionMajor
        self.path_plugin = pluginPath
        self.path_libCpp = libCppPath
        self.current_plugin_name = currentPluginName
        self.settings = settings
        self.iPyProject = iPyProject
        self.isModelManagementPlugin = False
        self.plugin_name = None
        self.referenceLayer = None
        if self.current_plugin_name == MMTDefinitions.CONST_SETTINGS_PLUGIN_NAME:
            self.isModelManagementPlugin = True
            self.plugin_name = MMTDefinitions.CONST_SETTINGS_PLUGIN_NAME
        self.setupUi(self)
        # self.pluginQLidarInstance = None
        self.pluginQLidarInstance = utils.plugins['qLidar']
        self.pluginPhotogrammetryToolsInstance = utils.plugins['photogrammetry_tools']
        self.initialize()

        #### depuracion report
        # report = Report(self.iface,self.path_plugin)
        # reportType = 'PhHotspot'
        # reportSucess, strError = report.initialize(reportType)
        # if not reportSucess:
        #     msgBox = QMessageBox(self)
        #     msgBox.setIcon(QMessageBox.Information)
        #     msgBox.setWindowTitle(self.windowTitle)
        #     msgBox.setText(strError)
        #     msgBox.exec_()
        #     return

        ####

    def addPhotogrammetryConnection(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        items = []
        items.append(MMTDefinitions.CONST_NO_COMBO_SELECT)
        self.getPhotogrammetrySpatialiteConnections()
        for connection in self.photogrammetryConnections.keys():
            if not connection in self.photogrammetryConnectionsInProject:
                items.append(connection)
        item, ok = QInputDialog.getItem(self, "Select Photogrammetry Project",
                                        "Photogrammetry Project:", items, 0, False)
        if ok and item:
            if item == MMTDefinitions.CONST_NO_COMBO_SELECT:
                return
            connectionName = item
            photogrammetrySpatialiteDbFileName = self.photogrammetryConnections[connectionName]
            ret = self.iPyProject.mmtAddPhotogrammetryDb(dbFileName,
                                                         photogrammetrySpatialiteDbFileName)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                return
            else:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Process completed successfully")
                msgBox.exec_()
            self.photogrammetryConnectionsInProject[connectionName] = photogrammetrySpatialiteDbFileName
            self.photogrammetriesComboBox.clear()
            self.photogrammetriesComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
            for photogrammetryConnectionInProject in self.photogrammetryConnectionsInProject.keys():
                self.photogrammetriesComboBox.addItem(photogrammetryConnectionInProject)
        return

    def addPointCloud(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        strDir = QFileDialog.getExistingDirectory(self, "Select point cloud path", self.path,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            for pointCloud in self.pointCloudsInProject:
                if pointCloud.lower() == strDir.lower():
                    return
            ret = self.iPyProject.mmtAddPointCloud(dbFileName, strDir)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.pmOutputPathLineEdit.setText("")
                self.projectManagerOutputPath = None
                return
            else:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Process completed successfully")
                msgBox.exec_()
            self.pointCloudsInProject.append(strDir)
            self.pointCloudsComboBox.clear()
            self.pointCloudsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
            for pointCloud in self.pointCloudsInProject:
                self.pointCloudsComboBox.addItem(pointCloud)
            self.projectManagerOutputPath = strDir
            self.settings.setValue("project_management_output_path", self.projectManagerOutputPath)
            self.settings.sync()
            self.pmOutputPathLineEdit.setText(strDir)
        return

    def field_to_value_map(self, vLayer, field, list_values):
        # config = {'map': list_values, 'AllowNull': False}
        config = {'map': list_values}
        widget_setup = QgsEditorWidgetSetup('ValueMap', config)
        field_idx = vLayer.fields().indexFromName(field)
        vLayer.setEditorWidgetSetup(field_idx, widget_setup)
        # pichurri
        form_config = vLayer.editFormConfig()
        form_config.setReuseLastValue(field_idx, True)
        vLayer.setEditFormConfig(form_config)

    def addVirtualRoadMarksLayers(self):
        projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(self.crsEpsgCode)
        # catalogueFileNames = []
        # recuperar los ficheros de marcas
        uri = QgsDataSourceUri()
        uri.setDatabase(self.dbFileName)
        schema = ''
        roadMarksTable = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_TABLE_NAME
        roadMarksGeomColumn = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_GEOMETRY_COLUMN
        uri.setDataSource(schema, roadMarksTable, roadMarksGeomColumn)
        roadMarkslayer = QgsVectorLayer(uri.uri(), 'road_marks', 'spatialite')
        if not roadMarkslayer.isValid():
            return  # cuando todavia no se han procesado road_marks
        # for roadMarkFeature in roadMarkslayer.getFeatures():
        #     mark_file = roadMarkFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_FIELD_ROAD_MARKS_FILE]
        #     if not mark_file in catalogueFileNames:
        #         catalogueFileNames.append(mark_file)
        # recuperar los valores del catalogo
        uri = QgsDataSourceUri()
        uri.setDatabase(self.dbFileName)
        schema = ''
        catalogTable = MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_TABLE_NAME
        catalogGeomColumn = MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_GEOMETRY
        uri.setDataSource(schema, catalogTable, catalogGeomColumn)
        cataloguelayer = QgsVectorLayer(uri.uri(), 'catalogue', 'spatialite')
        if not cataloguelayer.isValid():
            return  # cuando todavia no se han procesado road_marks
            # if vlayer.featureCount() == 0:
            #     return
            # QgsProject.instance().addMapLayer(vlayer, False)
            # self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
            # vlayer.loadNamedStyle(self.qmlRoadMarksFileName)
            # vlayer.triggerRepaint()
            # self.iface.setActiveLayer(vlayer)
            # self.iface.zoomToActiveLayer()
        catalogueWidths = []
        catalogueValuesById = {}
        for catalogueFeature in cataloguelayer.getFeatures():
            strId = catalogueFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_ID]
            code = catalogueFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_CODE]
            type = catalogueFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_TYPE]
            img = catalogueFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_IMG]
            strEnabled = catalogueFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_ENABLED]
            strWidth = catalogueFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_WIDTH]
            if MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_TYPE_LONGITUDINAL_SUB_STRING in type:
                if not strWidth in catalogueWidths:
                    width = float(strWidth)
                    catalogueWidths.append(width)
            catalogueValues = {}
            catalogueValues[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_CODE] = code
            catalogueValues[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_TYPE] = type
            if strEnabled == '1':
                catalogueValues[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_ENABLED] = True
            else:
                catalogueValues[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_ENABLED] = False
            # catalogueValues[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_CODE] = code
            catalogueValues[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_IMG] = img
            id = int(strId)
            catalogueValuesById[id] = catalogueValues

        layerManualEditingLinearRoadMarksTitle = MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_NAME
        layerList = QgsProject.instance().mapLayersByName(layerManualEditingLinearRoadMarksTitle)
        if not layerList:
            self.manualEditingLinearRoadMarksLayer = None
            self.manualEditingLinearRoadMarksLayer = QgsVectorLayer("Linestring?crs=" + projectCrs.authid(),
                                                                    layerManualEditingLinearRoadMarksTitle, "memory")
            self.manualEditingLinearRoadMarksLayer.startEditing()
            widthFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_WIDTH
            widthField = QgsField(widthFieldName, QVariant.String)
            # catalogueFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_CATALOGUE_FILE
            # catalogueField = QgsField(catalogueFieldName, QVariant.String)
            # self.manualEditingLinearRoadMarksLayer.dataProvider().addAttributes([widthField, catalogueField])
            self.manualEditingLinearRoadMarksLayer.dataProvider().addAttributes([widthField])
            self.manualEditingLinearRoadMarksLayer.commitChanges()
            if self.manualEditingLinearRoadMarksLayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(self.manualEditingLinearRoadMarksLayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(self.manualEditingLinearRoadMarksLayer))
                self.manualEditingLinearRoadMarksLayer.loadNamedStyle(self.qmlManualEditingLinearRoadMarksFileName)
                # formConfig = manualEditingLinearRoadMarksLayer.editFormConfig()
                # formConfig.setReadOnly(0, True)
                # manualEditingLinearRoadMarksLayer.setEditFormConfig(formConfig)
                widthlistValues = {}
                # widthlistValues = {'0.1': 1, '0.15': 2}
                pos = 0
                for width in catalogueWidths:
                    widthlistValues[str(width)] = pos
                    pos = pos + 1
                self.field_to_value_map(self.manualEditingLinearRoadMarksLayer, widthFieldName, widthlistValues)
                listValues = {"kakita 1": 1, "kakita 2": 2}
                # catalogueFilesListValues = {}
                # pos = 0
                # for catalogueFile in catalogueFileNames:
                #     catalogueFilesListValues[catalogueFile] = pos
                #     pos = pos + 1
                # self.field_to_value_map(self.manualEditingLinearRoadMarksLayer, catalogueFieldName,
                #                         catalogueFilesListValues)
                # widthFieldIndex = fields.indexFromName(field_name)
                self.manualEditingLinearRoadMarksLayer.triggerRepaint()
                self.iface.setActiveLayer(self.manualEditingLinearRoadMarksLayer)
                self.iface.zoomToActiveLayer()
                self.manualEditingLinearRoadMarksLayer.startEditing()
            else:
                self.manualEditingLinearRoadMarksLayer = None
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Impossible to Load table: " + layerManualEditingLinearRoadMarksTitle
                               + " into QGIS")
                msgBox.exec_()
        layerManualEditingNonLinearRoadMarksTitle = MMTDefinitions.CONST_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_NAME
        layerList = QgsProject.instance().mapLayersByName(layerManualEditingNonLinearRoadMarksTitle)
        catalogImgsPath = self.path_plugin + "/" + MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_PATH_IMGS
        if not layerList:
            self.manualEditingNonLinearRoadMarksLayer = None
            self.manualEditingNonLinearRoadMarksLayer = QgsVectorLayer("Linestring?crs=" + projectCrs.authid(),
                                                                       layerManualEditingNonLinearRoadMarksTitle,
                                                                       "memory")
            self.manualEditingNonLinearRoadMarksLayer.startEditing()
            imgFieldName = MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_IMG
            imgField = QgsField(imgFieldName, QVariant.String)
            self.manualEditingNonLinearRoadMarksLayer.dataProvider().addAttributes(
                [imgField])
            self.manualEditingNonLinearRoadMarksLayer.commitChanges()
            if self.manualEditingNonLinearRoadMarksLayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(self.manualEditingNonLinearRoadMarksLayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(self.manualEditingNonLinearRoadMarksLayer))
                self.manualEditingNonLinearRoadMarksLayer.loadNamedStyle(
                    self.qmlManualEditingNonLinearRoadMarksFileName)
                field = MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_IMG
                widgetImg = QgsEditorWidgetSetup(
                    'ExternalResource',
                    {
                        # 'name':'symbol',
                        # 'PropertyCollection': {'name': 'symbol'},
                        'FileWidget': True,
                        'DefaultRoot': catalogImgsPath,
                        'DocumentViewer': 1,
                        'RelativeStorage': 0,
                        'StorageMode': 0,
                        'DocumentViewerHeight': 0,
                        'FileWidgetButton': True,
                        'DocumentViewerWidth': 100,
                        'FileWidgetFilter': '*.png'
                    })
                index = self.manualEditingNonLinearRoadMarksLayer.fields().indexFromName(field)
                aux_value = self.manualEditingNonLinearRoadMarksLayer.setEditorWidgetSetup(index, widgetImg)
                self.manualEditingNonLinearRoadMarksLayer.triggerRepaint()
                self.iface.setActiveLayer(self.manualEditingNonLinearRoadMarksLayer)
                self.iface.zoomToActiveLayer()
                self.manualEditingNonLinearRoadMarksLayer.startEditing()
            else:
                self.manualEditingNonLinearRoadMarksLayer = None
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Impossible to Load table: " + layerManualEditingNonLinearRoadMarksTitle
                               + " into QGIS")
                msgBox.exec_()

        # layerManualEditingNonLinearRoadMarksTitle = MMTDefinitions.CONST_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_NAME
        # layerList = QgsProject.instance().mapLayersByName(layerManualEditingNonLinearRoadMarksTitle)
        # if not layerList:
        #     self.manualEditingNonLinearRoadMarksLayer = None
        #     self.manualEditingNonLinearRoadMarksLayer = QgsVectorLayer("Point?crs=" + projectCrs.authid(),
        #                                                                layerManualEditingNonLinearRoadMarksTitle,
        #                                                                "memory")
        #     self.manualEditingNonLinearRoadMarksLayer.startEditing()
        #     roadMarkIdFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_FIELD_ROAD_MARK_ID
        #     roadMarkIdField = QgsField(roadMarkIdFieldName, QVariant.String)
        #     codeFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_FIELD_ROAD_MARK_CODE
        #     codeField = QgsField(codeFieldName, QVariant.String)
        #     typeFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_FIELD_ROAD_MARK_TYPE
        #     typeField = QgsField(typeFieldName, QVariant.String)
        #     # catalogueFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_FIELD_CATALOGUE_FILE
        #     # catalogueField = QgsField(catalogueFieldName, QVariant.String)
        #     # self.manualEditingNonLinearRoadMarksLayer.dataProvider().addAttributes(
        #     #     [roadMarkIdField, codeField, typeField, catalogueField])
        #     self.manualEditingNonLinearRoadMarksLayer.dataProvider().addAttributes(
        #         [roadMarkIdField, codeField, typeField])
        #     self.manualEditingNonLinearRoadMarksLayer.commitChanges()
        #     if self.manualEditingNonLinearRoadMarksLayer.isValid():
        #         # if vlayer.featureCount() == 0:
        #         #     return
        #         QgsProject.instance().addMapLayer(self.manualEditingNonLinearRoadMarksLayer, False)
        #         self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(self.manualEditingNonLinearRoadMarksLayer))
        #         self.manualEditingNonLinearRoadMarksLayer.loadNamedStyle(
        #             self.qmlManualEditingNonLinearRoadMarksFileName)
        #         roadMarkIdlistValues = {}
        #         codelistValues = {}
        #         typelistValues = {}
        #         # widthlistValues = {'0.1': 1, '0.15': 2}
        #         pos = 0
        #         for roadMarkId in catalogueValuesById.keys():
        #             roadMarkIdlistValues[str(roadMarkId)] = pos
        #             code = catalogueValuesById[roadMarkId][
        #                 MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_CODE]
        #             type = catalogueValuesById[roadMarkId][
        #                 MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_TYPE]
        #             codelistValues[code] = pos
        #             typelistValues[type] = pos
        #             pos = pos + 1
        #         self.field_to_value_map(self.manualEditingNonLinearRoadMarksLayer, roadMarkIdFieldName,
        #                                 roadMarkIdlistValues)
        #         self.field_to_value_map(self.manualEditingNonLinearRoadMarksLayer, codeFieldName, codelistValues)
        #         self.field_to_value_map(self.manualEditingNonLinearRoadMarksLayer, typeFieldName, typelistValues)
        #         # catalogueFilesListValues = {}
        #         # pos = 0
        #         # for catalogueFile in catalogueFileNames:
        #         #     catalogueFilesListValues[catalogueFile] = pos
        #         #     pos = pos + 1
        #         # self.field_to_value_map(self.manualEditingNonLinearRoadMarksLayer, catalogueFieldName,
        #         #                         catalogueFilesListValues)
        #         self.manualEditingNonLinearRoadMarksLayer.triggerRepaint()
        #         self.iface.setActiveLayer(self.manualEditingNonLinearRoadMarksLayer)
        #         self.iface.zoomToActiveLayer()
        #         self.manualEditingNonLinearRoadMarksLayer.startEditing()
        #     else:
        #         self.manualEditingNonLinearRoadMarksLayer = None
        #         msgBox = QMessageBox(self)
        #         msgBox.setIcon(QMessageBox.Information)
        #         msgBox.setWindowTitle(self.windowTitle)
        #         msgBox.setText("Impossible to Load table: " + layerManualEditingNonLinearRoadMarksTitle
        #                        + " into QGIS")
        #         msgBox.exec_()
        return

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def createProject(self):
        projectType = self.projectTypeComboBox.currentText()
        if projectType == MMTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project type")
            msgBox.exec_()
            return
        crs = self.projectQgsProjectionSelectionWidget.crs()
        isValidCrs = crs.isValid()
        crsAuthId = crs.authid()
        if not "EPSG:" in crsAuthId:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not EPSG")
            msgBox.exec_()
            return
        crsEpsgCode = int(crsAuthId.replace('EPSG:', ''))
        crsOsr = osr.SpatialReference()  # define test1
        if crsOsr.ImportFromEPSG(crsEpsgCode) != 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error importing OSR CRS from EPSG code" + str(crsEpsgCode))
            msgBox.exec_()
            return
        if not crsOsr.IsProjected():
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not a projected CRS")
            msgBox.exec_()
            return
        altitudeIsMsl = True
        verticalCrsEpsgCode = -1
        if self.projVersionMajor < 8:
            if self.projectAltitudeEllipsoidRadioButton.isChecked():
                altitudeIsMsl = False
        else:
            verticalCrsStr = self.verticalCRSsComboBox.currentText()
            if not verticalCrsStr == MMTDefinitions.CONST_ELLIPSOID_HEIGHT:
                verticalCrsEpsgCode = int(verticalCrsStr.replace('EPSG:', ''))
        dbFileName = self.databaseLineEdit.text()
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        strRoisShapefiles = ''
        cont = 0
        for roiShapefile in self.roisShapefiles:
            if cont > 0:
                strRoisShapefiles = strRoisShapefiles + self.parametersFromPythonStringSeparator
            strRoisShapefiles = strRoisShapefiles + roiShapefile
            cont = cont + 1
        if self.projVersionMajor < 8:
            ret = self.iPyProject.mmtCreateProject(dbFileName,
                                                   projectType,
                                                   crsEpsgCode,
                                                   altitudeIsMsl,
                                                   strRoisShapefiles)
        else:
            ret = self.iPyProject.mmtCreateProject(dbFileName,
                                                   projectType,
                                                   crsEpsgCode,
                                                   verticalCrsEpsgCode,
                                                   strRoisShapefiles)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        connectionName = QFileInfo(dbFileName).fileName()
        con = [connectionName, dbFileName]
        QSettings().setValue("SpatiaLite/connections/%s/sqlitepath" % (con[0]), con[1])
        self.iface.reloadConnections()
        self.getModelManagementSpatialiteConnections()
        msgBox = QMessageBox(self)
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(self.windowTitle)
        msgBox.setText("Process completed successfully")
        msgBox.exec_()
        return

    def getCommands(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtGetCommands(dbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        commands = []
        cont = 0
        for value in ret:
            if cont > 0:
                commands.append(value)
            cont = cont + 1
        self.processCommandComboBox.clear()
        self.processCommandComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for pointCloudCommand in commands:
            self.processCommandComboBox.addItem(pointCloudCommand)
        return

    def getModelManagementSpatialiteConnections(self):
        self.modelManagementConnections = {}
        settings = QSettings()
        settings.beginGroup('/SpatiaLite/connections')
        list_str_keys = settings.allKeys()
        paths = []
        for key in list_str_keys:
            if key != 'selected':
                paths.append(settings.value(key))
        ret = self.iPyProject.getModelDbSpatialiteDbs(paths)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmTemporalPathLineEdit.setText("")
            self.projectManagerTemporalPath = None
            return
        connectionNames = settings.childGroups()
        cont = 0
        for connectionName in connectionNames:
            path = paths[cont]
            if path in ret:
                self.modelManagementConnections[connectionName] = paths[cont]
            cont = cont + 1
        self.projectsComboBox.clear()
        self.projectsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for connection in self.modelManagementConnections.keys():
            self.projectsComboBox.addItem(connection)
        return

    def getPhotogrammetrySpatialiteConnections(self):
        self.photogrammetryConnections = {}
        settings = QSettings()
        settings.beginGroup('/SpatiaLite/connections')
        list_str_keys = settings.allKeys()
        paths = []
        for key in list_str_keys:
            paths.append(settings.value(key))
        ret = self.iPyProject.getPhotogrammetrySpatialiteDbs(paths)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmTemporalPathLineEdit.setText("")
            self.projectManagerTemporalPath = None
            return
        connectionNames = settings.childGroups()
        cont = 0
        for connectionName in connectionNames:
            path = paths[cont]
            if path in ret:
                self.photogrammetryConnections[connectionName] = paths[cont]
            cont = cont + 1
        # self.pointCloudsComboBox.clear()
        # self.pointCloudsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        # for pointCloudConnection in self.pointCloudConnections.keys():
        #     self.pointCloudsComboBox.addItem(pointCloudConnection)
        # return

    def getPhotogrammetrySpatialiteConnectionsInProject(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        self.photogrammetryConnectionsInProject = {}
        ret = self.iPyProject.mmtGetPhotogrammetrySpatialiteDbsInProject(dbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.getPhotogrammetrySpatialiteConnections()
        for photogrammetryConnection in self.photogrammetryConnections.keys():
            path = self.photogrammetryConnections[photogrammetryConnection]
            if path in ret:
                self.photogrammetryConnectionsInProject[photogrammetryConnection] = path
        self.photogrammetriesComboBox.clear()
        self.photogrammetriesComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for photogrammetryConnectionInProject in self.photogrammetryConnectionsInProject.keys():
            self.photogrammetriesComboBox.addItem(photogrammetryConnectionInProject)
        return

    def getPointCloudsInProject(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        self.pointCloudsInProject = []
        ret = self.iPyProject.mmtGetPointCloudsInProject(dbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        # self.getPhotogrammetrySpatialiteConnections()
        # for photogrammetryConnection in self.photogrammetryConnections.keys():
        #     path = self.photogrammetryConnections[photogrammetryConnection]
        #     if path in ret:
        #         self.photogrammetryConnectionsInProject[photogrammetryConnection] = path
        cont = 0
        for value in ret:
            if cont > 0:
                self.pointCloudsInProject.append(value)
            cont = cont + 1
        self.pointCloudsComboBox.clear()
        self.pointCloudsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for pointCloudInProject in self.pointCloudsInProject:
            self.pointCloudsComboBox.addItem(pointCloudInProject)
        return

    # def getPointCloudConnections(self):
    #     self.pointCloudConnections = {}
    #     settings = QSettings()
    #     settings.beginGroup('/SpatiaLite/connections')
    #     list_str_keys = settings.allKeys()
    #     paths = []
    #     for key in list_str_keys:
    #         paths.append(settings.value(key))
    #     ret = self.iPyProject.getPointCloudSpatialiteDbs(paths)
    #     if ret[0] == "False":
    #         msgBox = QMessageBox(self)
    #         msgBox.setIcon(QMessageBox.Information)
    #         msgBox.setWindowTitle(self.windowTitle)
    #         msgBox.setText("Error:\n" + ret[1])
    #         msgBox.exec_()
    #         self.pmTemporalPathLineEdit.setText("")
    #         self.projectManagerTemporalPath = None
    #         return
    #     connectionNames = settings.childGroups()
    #     cont = 0
    #     for connectionName in connectionNames:
    #         path = paths[cont]
    #         if path in ret:
    #             self.pointCloudConnections[connectionName] = paths[cont]
    #         cont = cont + 1
    #     # self.pointCloudsComboBox.clear()
    #     # self.pointCloudsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
    #     # for pointCloudConnection in self.pointCloudConnections.keys():
    #     #     self.pointCloudsComboBox.addItem(pointCloudConnection)
    #     # return

    def initialize(self):
        self.num_format = re.compile(r'^\-?[1-9][0-9]*\.?[0-9]*')
        self.dbFileName = None
        self.layerTreeName = None
        self.layerTree = None
        self.projectType = None
        self.modelManagementConnections = {}
        # self.pointCloudConnections = {}
        self.pointCloudsInProject = []
        self.photogrammetryConnections = {}
        self.photogrammetryConnectionsInProject = {}
        self.windowTitle = MMTDefinitions.CONST_PROGRAM_NAME
        self.path = self.settings.value("last_path")
        if not self.path:
            self.path = QDir.currentPath()
            self.settings.setValue("last_path", self.path)
            self.settings.sync()

        self.projectManagerTemporalPath = self.settings.value("project_management_temporal_path")
        auxDir = QDir(self.path)
        if not self.projectManagerTemporalPath or not auxDir.exists(self.projectManagerTemporalPath):
            self.projectManagerTemporalPath = self.path_libCpp + MMTDefinitions.CONST_PROJECT_MANAGEMENT_TEMPORAL_PATH
            self.settings.setValue("project_management_temporal_path", self.projectManagerTemporalPath)
            self.settings.sync()
        self.pmTemporalPathLineEdit.setText(self.projectManagerTemporalPath)

        self.sldFilesPath = self.path_plugin + MMTDefinitions.CONST_PROJECT_MANAGEMENT_SLD_FILES_PATH

        self.projectManagerOutputPath = self.settings.value("project_management_output_path")
        auxDir = QDir(self.path)
        if not self.projectManagerOutputPath or not auxDir.exists(self.projectManagerOutputPath):
            self.projectManagerOutputPath = self.path_libCpp + MMTDefinitions.CONST_PROJECT_MANAGEMENT_OUTPUT_PATH
            self.settings.setValue("project_management_output_path", self.projectManagerOutputPath)
            self.settings.sync()
        self.pmOutputPathLineEdit.setText(self.projectManagerOutputPath)

        qs = QSettings()
        spatialiteConnections = qs.value("SpatiaLite/connections")

        # template path que cuelga del directorio de este fichero
        pluginsPath = QFileInfo(QgsApplication.qgisUserDatabaseFilePath()).path()
        thisFilePath = os.path.dirname(os.path.realpath(__file__))
        thisFilePath = os.path.join(pluginsPath, thisFilePath)
        # templatePath = os.path.join(thisFilePath, PCTDefinitions.CONST_TEMPLATE_PATH)
        self.templatePath = thisFilePath + MMTDefinitions.CONST_TEMPLATE_PATH
        svg_paths = qs.value('svg/searchPathsForSVG')
        # if self.templatePath not in svg_paths:
        # qs.setValue('svg/searchPathsForSVG', svg_paths + [self.templatePath])
        qs.setValue('svg/searchPathsForSVG', self.templatePath)
        # if not svg_paths:
        # qs.setValue('svg/searchPathsForSVG', self.templatePath)
        # else:
        # qs.setValue('svg/searchPathsForSVG', svg_paths + [self.templatePath])

        self.qmlRoisFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_ROIS_TEMPLATE
        self.qmlAiPaintsImportFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_AI_PAINTS_IMPORT_TEMPLATE
        self.qmlAiRoadsImportFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_AI_ROADS_IMPORT_TEMPLATE
        self.qmlAiRoadsFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_AI_ROADS_TEMPLATE
        self.qmlAiPaintsTilesFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_AI_PAINTS_TILES_TEMPLATE
        self.qmlcvPhmPaintsFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_CV_PHM_PAINTS_TEMPLATE
        self.qmlRoadMarksFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_ROAD_MARKS_TEMPLATE
        self.qmlManualEditingLinearRoadMarksFileName = (self.templatePath
                                                        + MMTDefinitions.CONST_SYMBOLOGY_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_TEMPLATE)
        self.uiManualEditingLinearRoadMarksFileName = (self.templatePath
                                                       + MMTDefinitions.CONST_FORM_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_TEMPLATE)
        self.qmlManualEditingNonLinearRoadMarksFileName = (self.templatePath
                                                           + MMTDefinitions.CONST_SYMBOLOGY_MANUAL_EDITING_OF_NON_LINEAR_ROAD_MARKS_LAYER_TEMPLATE)
        self.qmlCubesFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_CUBES_TEMPLATE
        self.qmlAiRailsImportFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_AI_RAILS_IMPORT_TEMPLATE
        self.qmlAiRailwaysImportFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_AI_RAILWAYS_IMPORT_TEMPLATE
        self.qmlRailwayAxisPointsFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_RAILWAY_AXIS_POINTS_TEMPLATE
        self.qmlAiRailsFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_AI_RAILS_TEMPLATE
        self.qmlCvPhmRailsFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_CV_PHM_RAILS_TEMPLATE
        self.qmlAiRailsTilesFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_AI_RAILS_TILES_TEMPLATE
        self.qmlManualEditingRailwayAxisFromPointsFileName = (self.templatePath
                                                              + MMTDefinitions.CONST_SYMBOLOGY_MANUAL_EDITING_OF_RAILWAY_AXIS_FROM_POINTS_LAYER_TEMPLATE)

        # self.qmlPointCloudFileName = self.templatePath + PCTDefinitions.CONST_SYMBOLOGY_POINT_CLOUD_TEMPLATE
        ret = self.iPyProject.setModelDbManager()
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return

        ret = self.iPyProject.setPointCloudFileManager()
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return

        ret = self.iPyProject.setPhotogrammetryManager()
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return

        self.crsEpsgCode = -1
        self.verticalCrsEpsgCode = -1
        if self.projVersionMajor >= 8:
            self.projectQgsProjectionSelectionWidget.crsChanged.connect(self.setCrs)
            self.projectQgsProjectionSelectionWidget.cleared.connect(self.setCrs)
            self.verticalCRSsComboBox.addItem(MMTDefinitions.CONST_ELLIPSOID_HEIGHT)
        self.projectQgsProjectionSelectionWidget.setCrs(QgsCoordinateReferenceSystem(MMTDefinitions.CONST_DEFAULT_CRS))

        # if self.projVersionMajor >=8:
        #     self.addPCFsQgsProjectionSelectionWidget.crsChanged.connect(self.setCrsAddPCFs)
        #     self.addPCFsQgsProjectionSelectionWidget.cleared.connect(self.setCrsAddPCFs)
        #     self.addPCFsVerticalCRSsComboBox.addItem(PCTDefinitions.CONST_ELLIPSOID_HEIGHT)
        # self.addPCFsQgsProjectionSelectionWidget.setCrs(QgsCoordinateReferenceSystem(PCTDefinitions.CONST_DEFAULT_CRS))
        #
        # if self.projVersionMajor >=8:
        #     self.ppToolsIPCFsQgsProjectionSelectionWidget.crsChanged.connect(self.setCrsPpToolsIPCFs)
        #     self.ppToolsIPCFsQgsProjectionSelectionWidget.cleared.connect(self.setCrsPpToolsIPCFs)
        #     self.ppToolsIPCFsVerticalCRSsComboBox.addItem(PCTDefinitions.CONST_ELLIPSOID_HEIGHT)
        # self.ppToolsIPCFsQgsProjectionSelectionWidget.setCrs(QgsCoordinateReferenceSystem(PCTDefinitions.CONST_DEFAULT_CRS))

        # self.iPyModelManagementToolsProject=IPyModelManagementToolsProject()
        # self.iPyModelManagementToolsProject.setPythonModulePath(libCppPath)
        # ret = self.iPyModelManagementToolsProject.initialize()
        self.parametersFromPythonStringSeparator = self.iPyProject.getParametersFromPythonStringSeparator()
        ret = self.iPyProject.mmtSetProjectManagerTemporalPath(self.projectManagerTemporalPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmTemporalPathLineEdit.setText("")
            self.projectManagerTemporalPath = None
            return
        ret = self.iPyProject.mmtSetProjectManagerOutputPath(self.projectManagerOutputPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.pmOutputPathLineEdit.setText("")
            self.projectManagerOutputPath = None
            return

        self.roisShapefiles = []
        self.roisFileTypes = []
        self.roisFileTypes.append(MMTDefinitions.CONST_DOCUMENTS_TYPE_SHAPEFILE)
        self.roisFilesActiveFileExtensions = self.roisFileTypes

        self.roadFiles = []
        self.roadFilesFileTypes = []
        self.roadFilesFileTypes.append(MMTDefinitions.CONST_DOCUMENTS_TYPE_SHAPEFILE)
        # self.powerLinesFilesFileTypes.append(PCTDefinitions.CONST_DOCUMENTS_TYPE_LAZFILE)
        self.roadFilesActiveFileExtensions = self.roadFilesFileTypes

        self.railwayFiles = []
        self.railwayFilesFileTypes = []
        self.railwayFilesFileTypes.append(MMTDefinitions.CONST_DOCUMENTS_TYPE_SHAPEFILE)
        # self.powerLinesFilesFileTypes.append(PCTDefinitions.CONST_DOCUMENTS_TYPE_LAZFILE)
        self.railwayFilesActiveFileExtensions = self.railwayFilesFileTypes

        self.breakwaterFiles = []
        self.breakwaterFilesFileTypes = []
        self.breakwaterFilesFileTypes.append(MMTDefinitions.CONST_DOCUMENTS_TYPE_SHAPEFILE)
        # self.powerLinesFilesFileTypes.append(PCTDefinitions.CONST_DOCUMENTS_TYPE_LAZFILE)
        self.breakwaterFilesActiveFileExtensions = self.breakwaterFilesFileTypes

        self.layerTreeProject = None
        self.layerTreeProjectName = None
        self.aiPaintsImportVLayer = None
        self.aiRoadsImportVLayer = None
        self.aiRoadsVLayer = None
        self.aiPaintsTilesVLayer = None
        self.cvPhmPaintsVLayer = None
        self.roadMarksVLayer = None
        self.cubesVLayer = None
        self.aiRailsImportVLayer = None
        self.aiRailwaysImportVLayer = None
        self.aiRailsTilesVLayer = None
        self.railwayAxisPointsVLayer = None
        self.aiRailsVLayer = None
        self.cvPhmRailsVLayer = None
        self.mergedRailsVLayer = None
        # self.layerTreePCTiles = None
        # self.layerTreePCTilesName = None
        # self.loadedTiles = []
        # self.pvAnomaliesVLayer = None
        # self.pvAnomaliesPanelsVLayer = None

        # set projectManagement active
        self.modelManagementToolBox.setCurrentIndex(0)

        self.modelManagementToolBox.currentChanged.connect(self.onModelManagementToolBoxChanged)

        ###################################################
        # Project Management Page
        ###################################################

        # Projects spatialite databases
        self.getModelManagementSpatialiteConnections()
        self.projectsComboBox.currentIndexChanged.connect(self.selectProject)

        # Project
        self.openProjectPushButton.clicked.connect(self.openProject)
        self.closeProjectPushButton.clicked.connect(self.closeProject)

        self.projectManagementTabWidget.currentChanged.connect(self.onProjectManagementTabWidgetChanged)

        # Project types
        self.projecTypes = self.iPyProject.mmtGetProjectTypes()
        self.projectTypeComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for projectType in self.projecTypes:
            self.projectTypeComboBox.addItem(projectType)
        self.projectTypeComboBox.currentIndexChanged.connect(self.selectProjectType)

        # Parameters
        self.projectParametersPushButton.clicked.connect(self.selectProjectParameters)

        # DbFile
        self.databasePushButton.clicked.connect(self.selectNewDatabase)

        self.projectManagementTabWidget.setTabEnabled(0, True)
        self.projectManagementTabWidget.setTabEnabled(1, False)
        self.projectManagementTabWidget.setTabEnabled(2, False)
        self.projectManagementTabWidget.setTabEnabled(3, False)
        self.projectManagementTabWidget.setCurrentIndex(0)
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)

        # ROIs
        self.roisPushButton.clicked.connect(self.selectRois)
        self.numberOfRoisLineEdit.setText("0")

        # create
        self.createProjectPushButton.clicked.connect(self.createProject)

        # self.selectPLSFsPushButton.clicked.connect(self.selectPLSFs)
        # self.plsfNameShpRadioButton.clicked.connect(self.selectPLSFNameShp)
        # self.plsfNameInputRadioButton.clicked.connect(self.selectPLSFNameInput)
        # self.plsfNameFieldRadioButton.clicked.connect(self.selectPLSFNameField)
        # self.plsfNameInputPushButton.clicked.connect(self.selectPLSFNameInputValue)
        # self.plsfNameFieldPushButton.clicked.connect(self.selectPLSDNameFieldValue)

        # self.plsfElectricPylonsMinimumDistancePushButton.clicked.connect(self.selectMinimumDistanceBetweenElectricPylons)
        # self.plsfElectricPylonsBaseRadiusPushButton.clicked.connect(self.selectElectricPylonsBaseRadius)
        # self.plsfElectricPylonsHeightPushButton.clicked.connect(self.selectElectricPylonsHeight)

        # self.plsfProcessPushButton.clicked.connect(self.addPowerlinesFromShpProcess)
        #
        # self.selectSPSFsPushButton.clicked.connect(self.selectSPSFs)
        # self.spdSelectSFFieldsPushButton.clicked.connect(self.selectSPSFFields)
        # self.spsfProcessPushButton.clicked.connect(self.spsfProcess)

        # temporal path
        self.pmTemporalPathPushButton.clicked.connect(self.selectProjectManagerTemporalPath)
        self.pmOutputPathPushButton.clicked.connect(self.selectProjectManagerOutputPath)

        self.processingToolsPage.setEnabled(False)

        # ###################################################
        # # Processing ToolsPage
        # ###################################################
        self.addPointCloudPushButton.clicked.connect(self.addPointCloud)
        self.removePointCloudPushButton.clicked.connect(self.removePointCloud)
        self.openPointCloudPushButton.clicked.connect(self.openPointCloud)
        self.openPointCloudPushButton.setEnabled(False)
        self.pointCloudsComboBox.currentIndexChanged.connect(self.selectPointCloud)
        self.removePointCloudPushButton.setEnabled(False)
        #
        self.addPhotogrammetryPushButton.clicked.connect(self.addPhotogrammetryConnection)
        self.removePhotogrammetryPushButton.clicked.connect(self.removePhotogrammetryConnection)
        self.openPhotogrammetryPushButton.clicked.connect(self.openPhotogrammetry)
        self.openPhotogrammetryPushButton.setEnabled(False)
        self.photogrammetriesComboBox.currentIndexChanged.connect(self.selectPhotogrammetry)
        self.removePhotogrammetryPushButton.setEnabled(False)
        #
        self.processCommandComboBox.currentIndexChanged.connect(self.selectCommand)
        self.commandParamtersPushButton.clicked.connect(self.selectCommandParameters)
        self.processCommandPushButton.clicked.connect(self.selectCommandProcess)
        self.commandParamtersPushButton.setEnabled(False)
        self.processCommandPushButton.setEnabled(False)

        self.removeSelectedRoadMarksPushButton.clicked.connect(self.selectRemoveSelectedRoadMarks)
        self.enableSelectedRoadMarksPushButton.clicked.connect(self.selectEnableSelectedRoadMarks)
        self.disableSelectedRoadMarksPushButton.clicked.connect(self.selectDisableSelectedRoadMarks)
        self.saveLinearRoadMarksPushButton.clicked.connect(self.selectSaveManuallyEditedLinearRoadMarks)
        self.saveNonLinearRoadMarksPushButton.clicked.connect(self.selectSaveManuallyEditedNonLinearRoadMarks)

        self.breakwaterCubesSelectRegionByRectangleToolButton.clicked.connect(
            self.selectBreakwaterCubesRegionByRectangle)
        self.breakwaterCubesSelectRegionByPolygonToolButton.clicked.connect(self.selectBreakwaterCubesRegionByPolygon)
        self.breakwaterCubesSelectRegionByRectangleToolButton.setEnabled(False)
        self.breakwaterCubesSelectRegionByPolygonToolButton.setEnabled(False)
        self.breakwaterSegmentCubesRadioButton.setEnabled(False)
        self.breakwaterRemoveCubesRadioButton.setEnabled(False)

        self.removeSelectedAiRailsPushButton.clicked.connect(self.selectRemoveSelectedAiRails)
        self.enableSelectedAiRailsPushButton.clicked.connect(self.selectEnableSelectedAiRails)
        self.disableSelectedAiRailsPushButton.clicked.connect(self.selectDisableSelectedAiRails)
        self.removeSelectedCvPhmRailsPushButton.clicked.connect(self.selectRemoveSelectedCvPhmRails)
        self.enableSelectedCvPhmRailsPushButton.clicked.connect(self.selectEnableSelectedCvPhmRails)
        self.disableSelectedCvPhmRailsPushButton.clicked.connect(self.selectDisableSelectedCvPhmRails)
        self.removeSelectedMergedRailsPushButton.clicked.connect(self.selectRemoveSelectedMergedRails)
        self.enableSelectedMergedRailsPushButton.clicked.connect(self.selectEnableSelectedMergedRails)
        self.disableSelectedMergedRailsPushButton.clicked.connect(self.selectDisableSelectedMergedRails)
        self.jointSelectedMergedRailsPushButton.clicked.connect(self.selectJointSelectedMergedRails)
        self.disjointSelectedMergedRailsPushButton.clicked.connect(self.selectDisjointSelectedMergedRails)
        self.selectMergedRailsByRailPushButton.clicked.connect(self.selectMergedRailsByRail)
        # self.unselectMergedRailsByRailPushButton.clicked.connect(self.unselectMergedRailsByRail)

        self.removeSelectedRailwayAxisPointsPushButton.clicked.connect(self.selectRemoveSelectedRailwayAxisPoints)
        self.enableSelectedRailwayAxisPointsPushButton.clicked.connect(self.selectEnableSelectedRailwayAxisPoints)
        self.disableSelectedRailwayAxisPointsPushButton.clicked.connect(self.selectDisableSelectedRailwayAxisPoints)
        self.computeManualEditedRailwayAxisPushButton.clicked.connect(self.computeManualEditedRailwayAxis)


    # self.reportGroupBox.setVisible(False)
    # self.reportGroupBox.setEnabled(False)
    # self.reportReferenceLayerComboBox.setFilters(QgsMapLayerProxyModel.RasterLayer)
    # self.reportReferenceLayerComboBox.layerChanged.connect(self.selectReportReferenceLayerComboBox)
    # self.reportSelectedFeatureCheckBox.stateChanged.connect(self.selectReportSelectedFeature)
    # # self.reportUpdatePushButton.clicked.connect(self.selectUpdateReferenceLayers)
    # self.reportArrayComboBox.currentIndexChanged.connect(self.selectReportArray)
    # self.reportMapPanelCheckBox.stateChanged.connect(self.selectMapPanelCheckBox)
    # self.reportPanelComboBox.currentIndexChanged.connect(self.selectReportPanel)
    # self.reportHotspotComboBox.currentIndexChanged.connect(self.selectReportHotspot)
    # self.reportProcessPushButton.clicked.connect(self.selectReportProcess)
    # self.mapPanel = self.reportMapPanelCheckBox.isChecked()

    def closeProject(self):
        if not self.dbFileName:
            return
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)
        # delete project in ram??
        root = QgsProject.instance().layerTreeRoot()
        self.removeGroup(root, self.layerTreeProjectName)
        self.dbFileName = None
        self.layerTreeProjectName = None
        self.layerTreeProject = None
        # self.layerTreePCTilesName = None
        # self.layerTreePCTiles = None
        self.projectsComboBox.setEnabled(True)
        self.projectsComboBox.setCurrentIndex(0)
        self.iface.mapCanvas().refresh()
        self.processingToolsPage.setEnabled(False)
        self.pointCloudsComboBox.clear()
        self.processCommandComboBox.clear()
        self.roadMarksVLayer = None
        self.manualEditingLinearRoadMarksLayer = None
        self.manualEditingNonLinearRoadMarksLayer = None
        self.cubesVLayer = None
        self.aiRailsImportVLayer = None
        self.aiRailwaysImportVLayer = None
        self.aiRailsTilesVLayer = None
        self.aiRailsVLayer = None
        self.cvPhmRailsVLayer = None
        self.mergedRailsVLayer = None
        self.projectType = None

        # self.pvAnomaliesVLayer = None
        # self.pvAnomaliesPanelsVLayer = None
        return

    def computeManualEditedRailwayAxis(self):
        return

    def addVirtualRailwayLayers(self):
        projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(self.crsEpsgCode)
        layerManualEditingRailwayAxisFromPointsTitle = MMTDefinitions.CONST_MANUAL_EDITING_OF_RAILWAY_AXIS_FROM_POINTS_LAYER_NAME
        layerList = QgsProject.instance().mapLayersByName(layerManualEditingRailwayAxisFromPointsTitle)
        if not layerList:
            self.layerManualEditingRailwayAxisFromPointsLayer = None
            self.layerManualEditingRailwayAxisFromPointsLayer = QgsVectorLayer("Linestring?crs=" + projectCrs.authid(),
                                                                    layerManualEditingRailwayAxisFromPointsTitle, "memory")
            self.layerManualEditingRailwayAxisFromPointsLayer.startEditing()
            idFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_WIDTH
            enabledField = QgsField(MMTDefinitions.CONST_MANUAL_EDITING_OF_RAILWAY_AXIS_FROM_POINTS_LAYER_FIELD_ENABLED, QVariant.Int)
            # catalogueFieldName = MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_CATALOGUE_FILE
            # catalogueField = QgsField(catalogueFieldName, QVariant.String)
            # self.manualEditingLinearRoadMarksLayer.dataProvider().addAttributes([widthField, catalogueField])
            self.layerManualEditingRailwayAxisFromPointsLayer.dataProvider().addAttributes([enabledField])
            self.layerManualEditingRailwayAxisFromPointsLayer.commitChanges()
            if self.layerManualEditingRailwayAxisFromPointsLayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(self.layerManualEditingRailwayAxisFromPointsLayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(self.layerManualEditingRailwayAxisFromPointsLayer))
                self.layerManualEditingRailwayAxisFromPointsLayer.loadNamedStyle(self.qmlManualEditingRailwayAxisFromPointsFileName)
                self.layerManualEditingRailwayAxisFromPointsLayer.triggerRepaint()
                self.iface.setActiveLayer(self.layerManualEditingRailwayAxisFromPointsLayer)
                self.iface.zoomToActiveLayer()
                self.layerManualEditingRailwayAxisFromPointsLayer.startEditing()
            else:
                self.layerManualEditingRailwayAxisFromPointsLayer = None
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Impossible to Load table: " + layerManualEditingRailwayAxisFromPointsTitle
                               + " into QGIS")
                msgBox.exec_()

        return

    def loadRailwayLayers(self):
        # self.aiRailsImportVLayer = None
        aiRailsImportTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_IMPORT_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(aiRailsImportTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = aiRailsImportTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_IMPORT_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = aiRailsImportTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlAiRailsImportFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.aiRailsImportVLayer = vlayer
        # self.aiRailwaysImportVLayer = None
        aiRailwaysImportTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILWAYS_IMPORT_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(aiRailwaysImportTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = aiRailwaysImportTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILWAYS_IMPORT_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = aiRailwaysImportTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlAiRailwaysImportFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.aiRailwaysImportVLayer = vlayer
        # self.aiRailsTilesVLayer = None
        aiRailsTilesTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_TILES_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(aiRailsTilesTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = aiRailsTilesTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_TILES_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = aiRailsTilesTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlAiRailsTilesFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.aiRailsTilesVLayer = vlayer
        # railway_axis_points
        railwayAxisPointsTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_RAILWAY_AXIS_POINTS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(railwayAxisPointsTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = railwayAxisPointsTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_RAILWAY_AXIS_POINTS_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = railwayAxisPointsTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlAiRailsFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.railwayAxisPointsVLayer = vlayer
                sldRailwayAxisPointsFileName = self.sldFilesPath + MMTDefinitions.CONST_SYMBOLOGY_SLD_RAILWAY_AXIS_POINTS_TEMPLATE
                self.railwayAxisPointsVLayer.saveSldStyle(sldRailwayAxisPointsFileName)
                if self.aiRailsImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailsImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailsImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiRailwaysImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailwaysImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailwaysImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiRailsTilesVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailsTilesVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailsTilesVLayer.id())
                    layerNode.setExpanded(False)
                layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.railwayAxisPointsVLayer.id())
                layerNode.setExpanded(True)
        # self.aiRailsImportVLayer = None
        aiRailsTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(aiRailsTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = aiRailsTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = aiRailsTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlAiRailsFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.aiRailsVLayer = vlayer
                sldAiRailsFileName = self.sldFilesPath + MMTDefinitions.CONST_SYMBOLOGY_SLD_AI_RAILS_TEMPLATE
                self.aiRailsVLayer.saveSldStyle(sldAiRailsFileName)
                if self.aiRailsImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailsImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailsImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiRailwaysImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailwaysImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailwaysImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiRailsTilesVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailsTilesVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailsTilesVLayer.id())
                    layerNode.setExpanded(False)
                layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailsVLayer.id())
                layerNode.setExpanded(True)
        # self.cvPhmRailsVLayer = None
        cvPhmRailsTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_CV_PHM_RAILS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(cvPhmRailsTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = cvPhmRailsTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_CV_PHM_RAILS_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = cvPhmRailsTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlCvPhmRailsFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.cvPhmRailsVLayer = vlayer
                sldCvPhmRailsFileName = self.sldFilesPath + MMTDefinitions.CONST_SYMBOLOGY_SLD_CV_PHM_RAILS_TEMPLATE
                self.cvPhmRailsVLayer.saveSldStyle(sldCvPhmRailsFileName)
                if self.aiRailsImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailsImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailsImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiRailwaysImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailwaysImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailwaysImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiRailsTilesVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailsTilesVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailsTilesVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiRailsVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailsVLayer.id()).setItemVisibilityChecked(True)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailsVLayer.id())
                    layerNode.setExpanded(False)
                layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.cvPhmRailsVLayer.id())
                layerNode.setExpanded(True)
        # self.mergedRailsVLayer = None
        mergedRailsTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(mergedRailsTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = mergedRailsTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = mergedRailsTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                # vlayer.loadNamedStyle(self.qmlCvPhmRailsFileName)
                category_field_name = MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_TABLE_FIELD_CATEGORY_SIMBOLOGY
                category_field_index = vlayer.fields().indexFromName(category_field_name)
                unique_values = vlayer.uniqueValues(category_field_index)
                category_list = []
                for value in unique_values:
                    symbol = QgsSymbol.defaultSymbol(vlayer.geometryType())
                    category = QgsRendererCategory(value, symbol, str(value))
                    category_list.append(category)
                    symbol.setWidthUnit(QgsUnitTypes.RenderPixels)
                    symbol.setWidth(MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_SIMBOLOGY_LINE_WIDTH)
                renderer = QgsCategorizedSymbolRenderer(category_field_name, category_list)
                vlayer.setRenderer(renderer)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.mergedRailsVLayer = vlayer
                qmlMergedRailsFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_MERGED_RAILS_TEMPLATE
                sldMergedRailsFileName = self.sldFilesPath + MMTDefinitions.CONST_SYMBOLOGY_SLD_MERGED_RAILS_TEMPLATE
                self.mergedRailsVLayer.saveNamedStyle(qmlMergedRailsFileName)
                self.mergedRailsVLayer.saveSldStyle(sldMergedRailsFileName)
                if self.aiRailsImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailsImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailsImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiRailwaysImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailwaysImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailwaysImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiRailsTilesVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailsTilesVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailsTilesVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiRailsVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRailsVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRailsVLayer.id())
                    layerNode.setExpanded(False)
                if self.cvPhmRailsVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.cvPhmRailsVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.cvPhmRailsVLayer.id())
                    layerNode.setExpanded(False)
                layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.mergedRailsVLayer.id())
                layerNode.setExpanded(False) # can be a lot of ...
        self.refreshMapCanvas()

    def loadCubes(self):
        # self.cubesVLayer = None
        cubesTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_CUBES_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(cubesTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = cubesTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_CUBES_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = cubesTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlCubesFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.cubesVLayer = vlayer

    def loadRoadMarksLayer(self):
        # self.aiRailsImportVLayer = None
        aiPaintsImportTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_PAINTS_IMPORT_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(aiPaintsImportTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = aiPaintsImportTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_PAINTS_IMPORT_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = aiPaintsImportTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlAiPaintsImportFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.aiPaintsImportVLayer = vlayer
        # self.aiRailwaysImportVLayer = None
        aiRoadsImportTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_ROADS_IMPORT_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(aiRoadsImportTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = aiRoadsImportTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_ROADS_IMPORT_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = aiRoadsImportTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlAiRoadsImportFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.aiRoadsImportVLayer = vlayer
        # self.aiRailsTilesVLayer = None
        aiPaintsTilesTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_PAINTS_TILES_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(aiPaintsTilesTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = aiPaintsTilesTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_PAINTS_TILES_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = aiPaintsTilesTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlAiPaintsTilesFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.aiPaintsTilesVLayer = vlayer
        # self.aiRailwaysImportVLayer = None
        aiRoadstTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_ROADS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(aiRoadstTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = aiRoadstTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_ROADS_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = aiRoadstTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlAiRoadsFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.aiRoadsVLayer = vlayer
                sldAiRoadsFileName = self.sldFilesPath + MMTDefinitions.CONST_SYMBOLOGY_SLD_AI_ROADS_TEMPLATE
                self.aiRoadsVLayer.saveSldStyle(sldAiRoadsFileName)
                if self.aiRoadsImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRoadsImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRoadsImportVLayer.id())
                    layerNode.setExpanded(False)
                layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRoadsVLayer.id())
                layerNode.setExpanded(True)

                # if self.aiPaintsImportVLayer.isValid():
                #     QgsProject.instance().layerTreeRoot().findLayer(
                #         self.aiPaintsImportVLayer.id()).setItemVisibilityChecked(False)
                # if self.aiPaintsTilesVLayer.isValid():
                #     QgsProject.instance().layerTreeRoot().findLayer(
                #         self.aiPaintsTilesVLayer.id()).setItemVisibilityChecked(False)

        # self.aiRailsImportVLayer = None
        # self.aiRailsImportVLayer = None
        cvPhmPaintsTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_CV_PHM_PAINTS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(cvPhmPaintsTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = cvPhmPaintsTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_CV_PHM_PAINTS_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = cvPhmPaintsTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlcvPhmPaintsFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.cvPhmPaintsVLayer = vlayer
                sldCvPhmPaintsFileName = self.sldFilesPath + MMTDefinitions.CONST_SYMBOLOGY_SLD_CV_PHM_PAINTS_TEMPLATE
                self.cvPhmPaintsVLayer.saveSldStyle(sldCvPhmPaintsFileName)
                if self.aiRoadsImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRoadsImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRoadsImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiPaintsImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiPaintsImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiPaintsImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiPaintsTilesVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiPaintsTilesVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiPaintsTilesVLayer.id())
                    layerNode.setExpanded(False)
                # if self.aiRoadsVLayer.isValid():
                #     QgsProject.instance().layerTreeRoot().findLayer(
                #         self.aiRoadsVLayer.id()).setItemVisibilityChecked(False)
                layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.cvPhmPaintsVLayer.id())
                layerNode.setExpanded(True)

        # self.roadMarksVLayer = None
        roadMarksTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(roadMarksTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = roadMarksTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = roadMarksTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlRoadMarksFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                self.roadMarksVLayer = vlayer
                sldRoadMarksFileName = self.sldFilesPath + MMTDefinitions.CONST_SYMBOLOGY_SLD_ROAD_MARKS_TEMPLATE
                self.roadMarksVLayer.saveSldStyle(sldRoadMarksFileName)
                if self.aiRoadsImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiRoadsImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiRoadsImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiPaintsImportVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiPaintsImportVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiPaintsImportVLayer.id())
                    layerNode.setExpanded(False)
                if self.aiPaintsTilesVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.aiPaintsTilesVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.aiPaintsTilesVLayer.id())
                    layerNode.setExpanded(False)
                # if self.aiRoadsVLayer.isValid():
                #     QgsProject.instance().layerTreeRoot().findLayer(
                #         self.aiRoadsVLayer.id()).setItemVisibilityChecked(False)
                if self.cvPhmPaintsVLayer.isValid():
                    QgsProject.instance().layerTreeRoot().findLayer(
                        self.cvPhmPaintsVLayer.id()).setItemVisibilityChecked(False)
                    layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.cvPhmPaintsVLayer.id())
                    layerNode.setExpanded(False)
                layerNode = QgsProject.instance().layerTreeRoot().findLayer(self.roadMarksVLayer.id())
                layerNode.setExpanded(True)
            # else: # cuando todavia no se han procesado road_marks
            #     msgBox = QMessageBox(self)
            #     msgBox.setIcon(QMessageBox.Information)
            #     msgBox.setWindowTitle(self.windowTitle)
            #     msgBox.setText("Impossible to Load table: " + roadMarksTableName
            #                        +" into QGIS")
            #     msgBox.exec_()


    def loadROIsLayer(self):
        roisTableName = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROIS_TABLE_NAME
        layerList = QgsProject.instance().mapLayersByName(roisTableName)
        if not layerList:
            uri = QgsDataSourceUri()
            uri.setDatabase(self.dbFileName)
            schema = ''
            table = roisTableName
            geom_column = MMTDefinitions.CONST_SPATIALITE_LAYERS_ROIS_TABLE_GEOMETRY_COLUMN
            uri.setDataSource(schema, table, geom_column)
            display_name = roisTableName
            vlayer = QgsVectorLayer(uri.uri(), display_name, 'spatialite')
            if vlayer.isValid():
                # if vlayer.featureCount() == 0:
                #     return
                QgsProject.instance().addMapLayer(vlayer, False)
                self.layerTreeProject.insertChildNode(1, QgsLayerTreeLayer(vlayer))
                vlayer.loadNamedStyle(self.qmlRoisFileName)
                vlayer.triggerRepaint()
                self.iface.setActiveLayer(vlayer)
                self.iface.zoomToActiveLayer()
                sldRoisFileName = self.sldFilesPath + MMTDefinitions.CONST_SYMBOLOGY_SLD_ROIS_TEMPLATE
                vlayer.saveSldStyle(sldRoisFileName)
            else:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Impossible to Load table: " + roisTableName
                               + " into QGIS")
                msgBox.exec_()

    def onModelManagementToolBoxChanged(self, i):  # changed!
        # QMessageBox.information(self,
        #           "Model Management ToolBox Changed!",
        #           "Current Tab Index: %d" % i ) #changed!
        if i == 1:  # Processing tools
            self.editingProcessesTabWidget.setTabEnabled(0, False)
            self.editingProcessesTabWidget.setTabEnabled(1, False)
            self.editingProcessesTabWidget.setTabEnabled(2, False)
            self.editingProcessesTabWidget.setTabEnabled(3, False)
            if not self.dbFileName or not self.projectType:
                return
            if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_BREAKWATER.lower():
                self.editingProcessesTabWidget.setTabEnabled(0, True)
                self.editingProcessesTabWidget.setCurrentIndex(0)
            elif self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_RAILWAY.lower():
                self.editingProcessesTabWidget.setTabEnabled(1, True)
                self.editingProcessesTabWidget.setTabEnabled(3, True)
                self.editingProcessesTabWidget.setCurrentIndex(1)
            elif self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_ROAD.lower():
                self.editingProcessesTabWidget.setTabEnabled(2, True)
                self.editingProcessesTabWidget.setCurrentIndex(2)
                # self.saveNonLinearRoadMarksPushButton.setEnabled(False)
        return

    def onProjectManagementTabWidgetChanged(self, i):  # changed!
        # QMessageBox.information(self,
        #           "Tab Index Changed!",
        #           "Current Tab Index: %d" % i ) #changed!
        # if i==1: # add powerlines
        #     self.plsfNameShpRadioButton.setChecked(True)
        #     self.plsfNameInputLineEdit.clear()
        #     self.plsfNameFieldLineEdit.clear()
        #     strValueMinimuDistance = MMTDefinitions.CONST_LINEAR_COARSE_PRECISION.format(MMTDefinitions.CONST_POWERLINES_MINIMUM_DISTANCE_BETWEEN_ELECTRIC_PYLONS_DEFAULT_VALUE)
        #     self.plsfElectricPylonsMinimumDistanceLineEdit.setText(strValueMinimuDistance)
        #     strValueBaseRadius = MMTDefinitions.CONST_LINEAR_COARSE_PRECISION.format(MMTDefinitions.CONST_POWERLINES_ELECTRIC_PYLONS_BASE_RADIUS_DEFAULT_VALUE)
        #     self.plsfElectricPylonsBaseRadiusLineEdit.setText(strValueBaseRadius)
        #     strValueHeight = MMTDefinitions.CONST_LINEAR_COARSE_PRECISION.format(MMTDefinitions.CONST_POWERLINES_ELECTRIC_PYLONS_HEIGHT_DEFAULT_VALUE)
        #     self.plsfElectricPylonsHeightLineEdit.setText(strValueHeight)
        return

    def openPhotogrammetry(self):
        return

    def openPointCloud(self):
        return

    def openProject(self):
        self.closeProjectPushButton.setEnabled(False)
        self.dbFileName = None
        self.layerTreeName = None
        self.layerTree = None
        self.roadMarksVLayer = None
        self.manualEditingLinearRoadMarksLayer = None
        self.manualEditingNonLinearRoadMarksLayer = None
        connectionFileName = self.projectsComboBox.currentText()
        if connectionFileName == MMTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project before")
            msgBox.exec_()
            return
        connectionPath = self.modelManagementConnections[connectionFileName]
        ret = self.iPyProject.mmtOpenProject(connectionPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        if self.projVersionMajor < 8:
            ret = self.iPyProject.mmtGetProjectCrsEpsgCode(connectionPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            self.crsEpsgCode = ret[1]
            strCrsEpsgCode = MMTDefinitions.CONST_EPSG_PREFIX + str(self.crsEpsgCode)
        else:
            ret = self.iPyProject.mmtGetProjectCrsEpsgCodes(connectionPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.projectsComboBox.setCurrentIndex(0)
                return
            self.crsEpsgCode = ret[1]
            strCrsEpsgCode = MMTDefinitions.CONST_EPSG_PREFIX + str(self.crsEpsgCode)
            self.projectQgsProjectionSelectionWidget.setCrs(QgsCoordinateReferenceSystem(strCrsEpsgCode))
            self.verticalCrsEpsgCode = ret[2]
            #
            # self.addPCFsQgsProjectionSelectionWidget.setCrs(
            #     QgsCoordinateReferenceSystem(strCrsEpsgCode))
            # # self.addPCFsQgsProjectionSelectionWidget.setCrs(
            # #     QgsCoordinateReferenceSystem(qLidarDefinitions.CONST_DEFAULT_CRS))
            # self.setCrsAddPCFs()
            self.verticalCRSsComboBox.setCurrentIndex(0)
            if self.verticalCrsEpsgCode != -1:
                strVerticalCrsEpsgCode = MMTDefinitions.CONST_EPSG_PREFIX + str(self.verticalCrsEpsgCode)
                index = self.verticalCRSsComboBox.findText(strVerticalCrsEpsgCode, Qt.MatchFixedString)
                if index != -1:
                    self.verticalCRSsComboBox.setCurrentIndex(index)
        # establecer el crs del proyecto de qgis si no coincide con el del proyecto del plugin
        qgisProjectCrsAsEpsg = QgsProject.instance().crs().authid()
        if qgisProjectCrsAsEpsg.lower() != strCrsEpsgCode:
            projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(self.crsEpsgCode)
            QgsProject.instance().setCrs(projectCrs)
        ret = self.iPyProject.mmtGetProjectType(connectionPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            self.projectsComboBox.setCurrentIndex(0)
            return
        self.projectType = ret[1]
        self.dbFileName = connectionPath
        groupName = MMTDefinitions.CONST_LAYER_TREE_PROJECT_NAME
        self.layerTreeProjectName = groupName + connectionFileName
        root = QgsProject.instance().layerTreeRoot()
        # self.layerTreeProject = root.addGroup(self.layerTreeProjectName)
        self.layerTreeProject = root.insertGroup(0, self.layerTreeProjectName)
        self.loadROIsLayer()
        if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_ROAD.lower():
            self.loadRoadMarksLayer()
            self.addVirtualRoadMarksLayers()
        elif self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_BREAKWATER.lower():
            self.loadCubes()
        elif self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_RAILWAY.lower():
            self.loadRailwayLayers()
            self.addVirtualRailwayLayers()
        # if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_SOLARPARK.lower():
        #     self.loadPhotovoltaicArrayPanels()
        #     self.loadPhotovoltaicPanels()
        #     self.loadPhotovoltaicAnomaliesLayers()
        # self.loadTilesLayer()
        self.closeProjectPushButton.setEnabled(True)
        self.openProjectPushButton.setEnabled(False)
        self.projectsComboBox.setEnabled(False)
        self.projectManagementTabWidget.setEnabled(True)
        self.projectManagementTabWidget.setTabEnabled(0, False)
        # if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_POWERLINE.lower():
        #     self.projectManagementTabWidget.setTabEnabled(1, True)
        #     self.projectManagementTabWidget.setTabEnabled(2, False)
        #     self.plsfNameShpRadioButton.setChecked(True)
        #     self.selectPLSFNameShp()
        # if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_SOLARPARK.lower():
        #     self.projectManagementTabWidget.setTabEnabled(1, False)
        #     self.projectManagementTabWidget.setTabEnabled(2, True)
        #     self.spdSelectSFFieldsPushButton.setEnabled(False)
        #     self.spsfProcessPushButton.setEnabled(False)
        # # tilesTableName = PCTDefinitions.CONST_SPATIALITE_LAYERS_TILES_TABLE_NAME
        # # layerList = QgsProject.instance().mapLayersByName(tilesTableName)
        # # if not layerList:
        # #     self.projectManagementTabWidget.setTabEnabled(2, False)
        # # else:
        # #     tilesLayer = layerList[0]
        # #     if tilesLayer.featureCount() > 0:
        # #         self.projectManagementTabWidget.setTabEnabled(2, True)

        self.processingToolsPage.setEnabled(True)
        self.getPointCloudsInProject()
        self.getPhotogrammetrySpatialiteConnectionsInProject()
        self.getCommands()
        # # msgBox = QMessageBox(self)
        # # msgBox.setIcon(QMessageBox.Information)
        # # msgBox.setWindowTitle(self.windowTitle)
        # # msgBox.setText("Process completed successfully")
        # # msgBox.exec_()

        ret = self.iPyProject.mmtSetProjectManagerTemporalPath(self.projectManagerTemporalPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtSetProjectManagerOutputPath(self.projectManagerOutputPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtSetSldFilesPath(self.sldFilesPath)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.modelManagementToolBox.setCurrentIndex(1)

    def processCubesForRegion(self):
        segmentCubes = self.breakwaterSegmentCubesRadioButton.isChecked()
        removeCubes = self.breakwaterRemoveCubesRadioButton.isChecked()
        pointCloudPath = ''
        if removeCubes:
            if not self.cubesVLayer:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("There are not segmented cubes")
                msgBox.exec_()
                if self.toolRectangle:
                    self.toolRectangle.endSelection.disconnect(self.processCubesForRegion)
                elif self.toolPolygon:
                    self.toolPolygon.endSelection.disconnect(self.processCubesForRegion)
                return
        elif segmentCubes:
            pointCloudPath = self.pointCloudsComboBox.currentText()
            if pointCloudPath == MMTDefinitions.CONST_NO_COMBO_SELECT:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Select Point Cloud Project")
                msgBox.exec_()
                self.processCommandComboBox.setCurrentIndex(0)
                if self.toolRectangle:
                    self.toolRectangle.endSelection.disconnect(self.processCubesForRegion)
                elif self.toolPolygon:
                    self.toolPolygon.endSelection.disconnect(self.processCubesForRegion)
                return
        wktGeom = None
        if self.toolRectangle:
            wktGeom = self.toolRectangle.getWktGeomeetry()
            self.toolRectangle.endSelection.disconnect(self.processCubesForRegion)
            self.toolRectangle.rubberBand.hide()
            self.toolRectangle = None
            self.iface.mapCanvas().unsetMapTool(self.toolRectangle)
            self.breakwaterCubesSelectRegionByRectangleToolButton.setChecked(False)
        elif self.toolPolygon:
            wktGeom = self.toolPolygon.getWktGeomeetry()
            self.toolPolygon.endSelection.disconnect(self.processCubesForRegion)
            self.toolPolygon.rubberBand.hide()
            self.toolPolygon.rubberBand.reset(QgsWkbTypes.PolygonGeometry)
            self.toolPolygon.reset()
            self.toolPolygon = None
            self.iface.mapCanvas().unsetMapTool(self.toolPolygon)
            self.breakwaterCubesSelectRegionByPolygonToolButton.setChecked(False)
        if not wktGeom:
            return
        text = "It will proceed to "
        if segmentCubes:
            text += "segment cubes"
        elif removeCubes:
            text += "remove cubes"
        text += "\nfor the selected region"
        text += "\nThis process will update the project database"
        text += "\n\nDo you wish continue?"
        reply = QMessageBox.question(self.iface.mainWindow(), self.windowTitle,
                                     text, QMessageBox.Yes, QMessageBox.No)
        if reply != QMessageBox.Yes:
            return
        #     msgBox = QMessageBox(self)
        #     msgBox.setIcon(QMessageBox.Information)
        #     msgBox.setWindowTitle(self.windowTitle)
        #     msgBox.setText("Process finished:\n")
        #     msgBox.exec_()
        # else:
        #     return
        projectCrs = QgsProject.instance().crs()
        projectCrsEpsgCode = -1
        projectCrsProj4 = ""
        projectCrsAuthId = projectCrs.authid()
        if "EPSG" in projectCrsAuthId:
            projectCrsEpsgCode = int(projectCrsAuthId.replace("EPSG:", ""))
        projectCrsProj4 = projectCrs.toProj4()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        if segmentCubes:
            ret = self.iPyProject.mmtCubesSegmentationForWkt(dbFileName,
                                                             wktGeom,
                                                             projectCrsEpsgCode,
                                                             projectCrsProj4,
                                                             pointCloudPath)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                return
        elif removeCubes:
            ret = self.iPyProject.mmtRemoveCubesForWkt(dbFileName,
                                                       wktGeom,
                                                       projectCrsEpsgCode,
                                                       projectCrsProj4)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                return
        self.cubesVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()
        return

    def refreshMapCanvas(self):
        currentScale = self.iface.mapCanvas().scale()
        newScale = currentScale * 1.001
        self.iface.mapCanvas().zoomScale(newScale)

    def removeGroup(self, root, name):
        # root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(name)
        if not group is None:
            for child in group.children():
                dump = child.dump()
                id = dump.split("=")[-1].strip()
                QgsProject.instance().removeMapLayer(id)
            root.removeChildNode(group)

    def removePhotogrammetryConnection(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        selectedPhotogrammetryConnectionInProject = self.photogrammetriesComboBox.currentText()
        if selectedPhotogrammetryConnectionInProject == MMTDefinitions.CONST_NO_COMBO_SELECT:
            return
        photogrammetrySpatialiteDbFileName = self.photogrammetryConnectionsInProject[
            selectedPhotogrammetryConnectionInProject]
        ret = self.iPyProject.mmtRemovePhotogrammetryDb(dbFileName,
                                                        photogrammetrySpatialiteDbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        else:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process completed successfully")
            msgBox.exec_()
        del self.photogrammetryConnectionsInProject[selectedPhotogrammetryConnectionInProject]
        self.photogrammetriesComboBox.clear()
        self.photogrammetriesComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for photogrammetryConnectionInProject in self.photogrammetryConnectionsInProject.keys():
            self.photogrammetriesComboBox.addItem(photogrammetryConnectionInProject)
        return

    def removePointCloud(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        selectedPointCloudInProject = self.pointCloudsComboBox.currentText()
        if selectedPointCloudInProject == MMTDefinitions.CONST_NO_COMBO_SELECT:
            return
        ret = self.iPyProject.mmtRemovePointCloud(dbFileName,
                                                  selectedPointCloudInProject)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        else:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Process completed successfully")
            msgBox.exec_()
        self.pointCloudsInProject.remove(selectedPointCloudInProject)
        self.pointCloudsComboBox.clear()
        self.pointCloudsComboBox.addItem(MMTDefinitions.CONST_NO_COMBO_SELECT)
        for pointCloud in self.pointCloudsInProject:
            self.pointCloudsComboBox.addItem(pointCloud)
        return

    def selectBreakwaterCubesRegionByPolygon(self):
        if self.breakwaterSegmentCubesRadioButton.isChecked():
            pointCloudPath = self.pointCloudsComboBox.currentText()
            if pointCloudPath == MMTDefinitions.CONST_NO_COMBO_SELECT:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Select Point Cloud Project")
                msgBox.exec_()
                self.processCommandComboBox.setCurrentIndex(0)
                return
        self.breakwaterCubesSelectRegionByRectangleToolButton.setChecked(False)
        self.breakwaterCubesSelectRegionByPolygonToolButton.setChecked(True)
        self.toolRectangle = None
        self.toolPolygon = None
        self.toolPolygon = PolygonMapTool(self.iface.mapCanvas())
        self.iface.mapCanvas().setMapTool(self.toolPolygon)
        self.toolPolygon.endSelection.connect(self.processCubesForRegion)
        return

    def selectBreakwaterCubesRegionByRectangle(self):
        if self.breakwaterSegmentCubesRadioButton.isChecked():
            pointCloudPath = self.pointCloudsComboBox.currentText()
            if pointCloudPath == MMTDefinitions.CONST_NO_COMBO_SELECT:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Select Point Cloud Project")
                msgBox.exec_()
                self.processCommandComboBox.setCurrentIndex(0)
                return
        self.breakwaterCubesSelectRegionByRectangleToolButton.setChecked(True)
        self.breakwaterCubesSelectRegionByPolygonToolButton.setChecked(False)
        self.toolRectangle = None
        self.toolPolygon = None
        self.toolRectangle = RectangleMapTool(self.iface.mapCanvas())
        self.iface.mapCanvas().setMapTool(self.toolRectangle)
        self.toolRectangle.endSelection.connect(self.processCubesForRegion)
        return

    def selectCommand(self):
        self.breakwaterCubesSelectRegionByRectangleToolButton.setEnabled(False)
        self.breakwaterCubesSelectRegionByPolygonToolButton.setEnabled(False)
        if self.projectsComboBox.currentText() == MMTDefinitions.CONST_NO_COMBO_SELECT:
            return
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        # self.reportGroupBox.setVisible(False)
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            self.processCommandPushButton.setEnabled(False)
            return
        command = self.processCommandComboBox.currentText()
        if command == MMTDefinitions.CONST_NO_COMBO_SELECT:
            self.processCommandPushButton.setEnabled(False)
            self.commandParamtersPushButton.setEnabled(False)
            return
        ret = self.iPyProject.mmtGetCommandNeedsPointCloudDb(dbFileName, command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        needsPointCloudDb = False
        strNeeds = ret[1]
        strNeeds = strNeeds.lower()
        if strNeeds == "true":
            needsPointCloudDb = True
        ret = self.iPyProject.mmtGetCommandNeedsPhotogrammetryDb(dbFileName, command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        needsPhotogrammetryDb = False
        strNeeds = ret[1]
        strNeeds = strNeeds.lower()
        if strNeeds == "true":
            needsPhotogrammetryDb = True
        pointCloudPath = ""
        photogrammetrySpatialiteDbFileName = ""
        if needsPointCloudDb:
            pointCloudPath = self.pointCloudsComboBox.currentText()
            if pointCloudPath == MMTDefinitions.CONST_NO_COMBO_SELECT:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Select Point Cloud Project")
                msgBox.exec_()
                self.processCommandComboBox.setCurrentIndex(0)
                return
        if needsPhotogrammetryDb:
            selectedPhotogrammetryInProject = self.photogrammetriesComboBox.currentText()
            if selectedPhotogrammetryInProject == MMTDefinitions.CONST_NO_COMBO_SELECT:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Select Photogrammetry Project")
                msgBox.exec_()
                self.processCommandComboBox.setCurrentIndex(0)
                return
            photogrammetrySpatialiteDbFileName = self.photogrammetryConnectionsInProject[
                selectedPhotogrammetryInProject]
        # processCommandIsEnabled = self.iPyProject.mmtGetEnabledProcessCommand(command)
        # self.processCommandPushButton.setEnabled(processCommandIsEnabled)
        self.commandParamtersPushButton.setEnabled(True)
        ret = self.iPyProject.mmtGetCommandIsExecutable(dbFileName, command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        if ret[1] == 'True':
            self.processCommandPushButton.setEnabled(True)
        else:
            self.processCommandPushButton.setEnabled(False)
        if (command == MMTDefinitions.CONST_MODELBREAKWATERDEFINITIONS_COMMAND_CSSHP
                or command == MMTDefinitions.CONST_MODELBREAKWATERDEFINITIONS_COMMAND_RCSHP):
            self.breakwaterCubesSelectRegionByRectangleToolButton.setEnabled(True)
            self.breakwaterCubesSelectRegionByPolygonToolButton.setEnabled(True)
            if command == MMTDefinitions.CONST_MODELBREAKWATERDEFINITIONS_COMMAND_CSSHP:
                self.breakwaterSegmentCubesRadioButton.setChecked(True)
            else:
                self.breakwaterRemoveCubesRadioButton.setChecked(True)

    def selectCommandParameters(self):
        command = self.processCommandComboBox.currentText()
        if command == MMTDefinitions.CONST_NO_COMBO_SELECT:
            return
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtSelectCommandParameters(dbFileName, command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        return

    def selectCommandProcess(self):
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        command = self.processCommandComboBox.currentText()
        if command == MMTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select command to process")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtGetCommandNeedsPointCloudDb(dbFileName, command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        needsPointCloudDb = False
        strNeeds = ret[1]
        strNeeds = strNeeds.lower()
        if strNeeds == "true":
            needsPointCloudDb = True
        ret = self.iPyProject.mmtGetCommandNeedsPhotogrammetryDb(dbFileName, command)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        needsPhotogrammetryDb = False
        strNeeds = ret[1]
        strNeeds = strNeeds.lower()
        if strNeeds == "true":
            needsPhotogrammetryDb = True
        pointCloudPath = ""
        photogrammetrySpatialiteDbFileName = ""
        if needsPointCloudDb:
            pointCloudPath = self.pointCloudsComboBox.currentText()
            if pointCloudPath == MMTDefinitions.CONST_NO_COMBO_SELECT:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Select Point Cloud Project")
                msgBox.exec_()
                return
        if needsPhotogrammetryDb:
            selectedPhotogrammetryInProject = self.photogrammetriesComboBox.currentText()
            if selectedPhotogrammetryInProject == MMTDefinitions.CONST_NO_COMBO_SELECT:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Select Photogrammetry Project")
                msgBox.exec_()
                return
            photogrammetrySpatialiteDbFileName = self.photogrammetryConnectionsInProject[
                selectedPhotogrammetryInProject]
        if command == MMTDefinitions.CONST_MODELRAILWAYDEFINITIONS_COMMAND_CVPHOFSAIR:
            activeLayer = self.iface.activeLayer()
            activeLayerName = activeLayer.name()
            if activeLayerName != MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_TABLE_NAME:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                text = ("This command requieres active layer: "
                        + MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_TABLE_NAME)
                text += " and select features to process"
                msgBox.setText(text)
                msgBox.exec_()
                return
            numberOfFeaturesSelected = activeLayer.selectedFeatureCount()
            if numberOfFeaturesSelected < 1:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                text = ("This command requieres active layer: "
                        + MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_TABLE_NAME)
                text += " and select features to process"
                msgBox.setText(text)
                msgBox.exec_()
                return
            # fieldIdIdx = activeLayer.fieldNameIndex(MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_FIELD_ID)
            fieldIdIdx = activeLayer.fields().indexFromName(MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_FIELD_ID)
            if fieldIdIdx < 0:
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                text = ("This command requieres active layer: "
                        + MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_TABLE_NAME)
                text += " and select features to process"
                text += " and active layer does not has a field id"
                msgBox.setText(text)
                msgBox.exec_()
                return
            parameterTag = MMTDefinitions.CONST_MODELRAILWAYDEFINITIONS_COMMAND_CVPHOFSAIR_PARAMETER_TAG_SELECTED_RAILS_ID
            parameterValue = ""
            ret = self.iPyProject.mmtSetCommandParameterValue(dbFileName,
                                                              parameterTag,
                                                              parameterValue)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                return
            parameterValue = ""
            for selectedFeature in activeLayer.selectedFeatures():
                selectedFeatureGeometry = selectedFeature.geometry()
                if parameterValue != "":
                    parameterValue = parameterValue + ";"
                # selectedFeatureId = selectedFeature[MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_FIELD_ID]
                selectedFeatureId = str(selectedFeature.attribute(fieldIdIdx))
                parameterValue = parameterValue + selectedFeatureId
            parameterTag = MMTDefinitions.CONST_MODELRAILWAYDEFINITIONS_COMMAND_CVPHOFSAIR_PARAMETER_TAG_SELECTED_RAILS_ID
            ret = self.iPyProject.mmtSetCommandParameterValue(dbFileName,
                                                              parameterTag,
                                                              parameterValue)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                return
        initialDateTime = QDateTime.currentDateTime()
        ret = self.iPyProject.mmtProcessCommand(dbFileName,
                                                command,
                                                pointCloudPath,
                                                photogrammetrySpatialiteDbFileName)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            if command == MMTDefinitions.CONST_MODELRAILWAYDEFINITIONS_COMMAND_CVPHOFSAIR:
                parameterTag = MMTDefinitions.CONST_MODELRAILWAYDEFINITIONS_COMMAND_CVPHOFSAIR_PARAMETER_TAG_SELECTED_RAILS_ID
                parameterValue = ""
                ret = self.iPyProject.mmtSetCommandParameterValue(dbFileName,
                                                                  parameterTag,
                                                                  parameterValue)
                if ret[0] == "False":
                    msgBox = QMessageBox(self)
                    msgBox.setIcon(QMessageBox.Information)
                    msgBox.setWindowTitle(self.windowTitle)
                    msgBox.setText("Error:\n" + ret[1])
                    msgBox.exec_()
                    return
            return
        finalDateTime = QDateTime.currentDateTime()
        initialSeconds = initialDateTime.toTime_t()
        finalSeconds = finalDateTime.toTime_t()
        totalDurationSeconds = finalSeconds - initialSeconds
        durationDays = floor(totalDurationSeconds / 60.0 / 60.0 / 24.0)
        durationHours = floor((totalDurationSeconds - durationDays * 60.0 * 60.0 * 24.0) / 60.0 / 60.0)
        durationMinutes = floor(
            (totalDurationSeconds - durationDays * 60.0 * 60.0 * 24.0 - durationHours * 60.0 * 60.0) / 60.0)
        durationSeconds = totalDurationSeconds - durationDays * 60.0 * 60.0 * 24.0 - durationHours * 60.0 * 60.0 - durationMinutes * 60.0
        msgTtime = "- Process time:\n"
        msgTtime += "  - Start time of the process ......................: "
        msgTtime += initialDateTime.toString("yyyy/MM/dd - hh/mm/ss.zzz")
        msgTtime += "\n"
        msgTtime += "  - End time of the process ........................: "
        msgTtime += finalDateTime.toString("yyyy/MM/dd - hh/mm/ss.zzz")
        msgTtime += "\n"
        msgTtime += "  - Number of total seconds ........................: "
        msgTtime += f"{totalDurationSeconds:.3f}"  # QString.number(totalDurationSeconds, 'f', 3)
        msgTtime += "\n"
        msgTtime += "    - Number of days ...............................: "
        msgTtime += str(durationDays)  # QString.number(durationDays)
        msgTtime += "\n"
        msgTtime += "    - Number of hours ..............................: "
        msgTtime += str(durationHours)  # QString.number(durationHours)
        msgTtime += "\n"
        msgTtime += "    - Number of minutes ............................: "
        msgTtime += str(durationMinutes)  # QString.number(durationMinutes)
        msgTtime += "\n"
        msgTtime += "    - Number of seconds ............................: "
        msgTtime += f"{durationSeconds:.3f}"  # QString.number(durationSeconds, 'f', 3)
        msgTtime += "\n"
        msg = "Process completed successfully"
        msg += "\n"
        msg += msgTtime
        msgBox = QMessageBox(self)
        msgBox.setIcon(QMessageBox.Information)
        msgBox.setWindowTitle(self.windowTitle)
        msgBox.setText(msg)
        msgBox.exec_()
        if ret[1] == "True":  # needReloadProject:
            msg = "Before the next step, QGis and the Project must be reopened "
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText(msg)
            msgBox.exec_()
        if command == MMTDefinitions.CONST_MODELRAILWAYDEFINITIONS_COMMAND_CVPHOFSAIR:
            parameterTag = MMTDefinitions.CONST_MODELRAILWAYDEFINITIONS_COMMAND_CVPHOFSAIR_PARAMETER_TAG_SELECTED_RAILS_ID
            parameterValue = ""
            ret = self.iPyProject.mmtSetCommandParameterValue(dbFileName,
                                                              parameterTag,
                                                              parameterValue)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                return
        if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_ROAD.lower():
            self.loadRoadMarksLayer()
            self.addVirtualRoadMarksLayers()
        elif self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_BREAKWATER.lower():
            self.loadCubes()
        elif self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_RAILWAY.lower():
            self.loadRailwayLayers()
        # if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_POWERLINE.lower():
        #     self.loadHazardAreasMshLayer()
        #     self.loadHazardAreasLayer()
        # if self.projectType.lower() == MMTDefinitions.CONST_PROJECT_TYPE_SOLARPARK.lower():
        #     self.loadPhotovoltaicArrayPanels()
        #     self.loadPhotovoltaicPanels()
        #     self.loadPhotovoltaicAnomaliesLayers()
        # self.refreshMapCanvas()
        return

    def selectDisableSelectedRailwayAxisPoints(self):
        return

    def selectEnableSelectedRailwayAxisPoints(self):
        return

    def selectNewDatabase(self):
        oldFileName = self.databaseLineEdit.text()
        title = "Select New Project File (.sqlite)"
        filters = "Project Files (*.sqlite)"
        fileName, _ = QFileDialog.getSaveFileName(self, title, self.path, filters)
        if fileName:
            fileInfo = QFileInfo(fileName)
            self.path = fileInfo.absolutePath()
            self.databaseLineEdit.setText(fileName)
            self.settings.setValue("last_path", self.path)
            self.settings.sync()
        return

    def selectPhotogrammetry(self):
        self.openPhotogrammetryPushButton.setEnabled(False)
        self.removePhotogrammetryPushButton.setEnabled(False)
        photogrammetry = self.photogrammetriesComboBox.currentText()
        if photogrammetry != MMTDefinitions.CONST_NO_COMBO_SELECT:
            self.removePhotogrammetryPushButton.setEnabled(True)

    def selectPointCloud(self):
        self.openPointCloudPushButton.setEnabled(False)
        self.removePointCloudPushButton.setEnabled(False)
        pointCloud = self.pointCloudsComboBox.currentText()
        if pointCloud != MMTDefinitions.CONST_NO_COMBO_SELECT:
            self.removePointCloudPushButton.setEnabled(True)

    def selectProject(self):
        self.openProjectPushButton.setEnabled(False)
        self.closeProjectPushButton.setEnabled(False)
        projectFileName = self.projectsComboBox.currentText()
        if projectFileName == MMTDefinitions.CONST_NO_COMBO_SELECT:
            self.projectManagementTabWidget.setEnabled(True)
            self.projectManagementTabWidget.setTabEnabled(0, True)
            self.projectManagementTabWidget.setTabEnabled(1, False)
            self.projectManagementTabWidget.setTabEnabled(2, False)
            self.projectManagementTabWidget.setCurrentIndex(0)
            if self.dbFileName:
                self.closeProject()
        else:
            self.projectManagementTabWidget.setEnabled(False)
            # self.projectManagementTabWidget.setTabEnabled(0, False)
            # self.projectManagementTabWidget.setTabEnabled(1, False)
            # self.projectManagementTabWidget.setTabEnabled(2, False)
            self.projectManagementTabWidget.setCurrentIndex(1)
            self.openProjectPushButton.setEnabled(True)
            self.closeProjectPushButton.setEnabled(False)
        return

    def selectProjectManagerOutputPath(self):
        strDir = QFileDialog.getExistingDirectory(self, "Select directory", self.projectManagerOutputPath,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            ret = self.iPyProject.mmtSetProjectManagerOutputPath(strDir)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.pmOutputPathLineEdit.setText("")
                self.projectManagerOutputPath = None
                return
            self.projectManagerOutputPath = strDir
            self.settings.setValue("project_management_output_path", self.projectManagerOutputPath)
            self.settings.sync()
            self.pmOutputPathLineEdit.setText(strDir)
        return

    def selectProjectManagerTemporalPath(self):
        strDir = QFileDialog.getExistingDirectory(self, "Select directory", self.projectManagerTemporalPath,
                                                  QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks)
        if strDir:
            ret = self.iPyProject.mmtSetProjectManagerTemporalPath(strDir)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                self.pmTemporalPathLineEdit.setText("")
                self.projectManagerTemporalPath = None
                return
            self.projectManagerTemporalPath = strDir
            self.settings.setValue("project_management_temporal_path", self.projectManagerTemporalPath)
            self.settings.sync()
            self.pmTemporalPathLineEdit.setText(strDir)
        return

    def selectProjectParameters(self):
        projectType = self.projectTypeComboBox.currentText()
        if projectType == MMTDefinitions.CONST_NO_COMBO_SELECT:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select project type before")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtSelectProjectParameters(projectType)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        return

    def selectProjectType(self):
        projectType = self.projectTypeComboBox.currentText()
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Project type: "+projectType)
        # msgBox.exec_()
        return

    def selectMergedRailsByRail(self):
        if not self.mergedRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("merged_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.mergedRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select one or more rail segments from merged_rails layer")
            msgBox.exec_()
            return
        fieldIdIdx = self.mergedRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_FIELD_RAIL_ID)
        selectedFeatures = self.mergedRailsVLayer.selectedFeatures()
        selectedMergedRailIds = []
        str_exp = ""
        for mergedRailFeature in selectedFeatures:
            mergedRailId = mergedRailFeature.attributes()[fieldIdIdx]
            if mergedRailId not in selectedMergedRailIds:
                if len(selectedMergedRailIds) > 0:
                    str_exp += " or "
                str_exp += ("\"" + MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_FIELD_RAIL_ID
                            + "\" = " + str(mergedRailId))
                selectedMergedRailIds.append(mergedRailId)
        self.mergedRailsVLayer.selectByExpression(str_exp)
        return

    def unselectMergedRailsByRail(self):
        return

    def selectDisjointSelectedMergedRails(self):
        if not self.mergedRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("merged_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.mergedRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from merged_rails layer")
            msgBox.exec_()
            return
        # text = "The joining process is not reversible"
        # text += "\nDo you wish to continue?"
        # reply = QMessageBox.question(self.iface.mainWindow(), "Disjoining merged rails",
        #                              text, QMessageBox.Yes, QMessageBox.No)
        # if reply != QMessageBox.Yes:
        #     return
        merged_rails_ids_to_disjoint = []
        fieldIdIdx = self.mergedRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_FIELD_RAIL_ID)
        str_ids = ''
        for i in range(numberOfSelected):
            mergedRailFeature = self.mergedRailsVLayer.selectedFeatures()[i]
            mergedRailId = mergedRailFeature.attributes()[fieldIdIdx]
            if mergedRailId not in merged_rails_ids_to_disjoint:
                merged_rails_ids_to_disjoint.append(mergedRailId)
                str_ids = str_ids + str(mergedRailId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        if len(merged_rails_ids_to_disjoint) < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select one or more merged rails to disjoint")
            msgBox.exec_()
            return
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtDisjointMergedRails(dbFileName, merged_rails_ids_to_disjoint)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        category_field_name = MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_TABLE_FIELD_CATEGORY_SIMBOLOGY
        category_field_index = self.mergedRailsVLayer.fields().indexFromName(category_field_name)
        unique_values = self.mergedRailsVLayer.uniqueValues(category_field_index)
        category_list = []
        for value in unique_values:
            symbol = QgsSymbol.defaultSymbol(self.mergedRailsVLayer.geometryType())
            category = QgsRendererCategory(value, symbol, str(value))
            category_list.append(category)
            symbol.setWidthUnit(QgsUnitTypes.RenderPixels)
            symbol.setWidth(MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_SIMBOLOGY_LINE_WIDTH)
        renderer = QgsCategorizedSymbolRenderer(category_field_name, category_list)
        self.mergedRailsVLayer.setRenderer(renderer)
        qmlMergedRailsFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_MERGED_RAILS_TEMPLATE
        sldMergedRailsFileName = self.sldFilesPath + MMTDefinitions.CONST_SYMBOLOGY_SLD_MERGED_RAILS_TEMPLATE
        self.mergedRailsVLayer.saveNamedStyle(qmlMergedRailsFileName)
        self.mergedRailsVLayer.saveSldStyle(sldMergedRailsFileName)
        self.mergedRailsVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectJointSelectedMergedRails(self):
        if not self.mergedRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("merged_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.mergedRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from merged_rails layer")
            msgBox.exec_()
            return
        # text = "The joining process is not reversible"
        # text += "\nDo you wish to continue?"
        # reply = QMessageBox.question(self.iface.mainWindow(), "Joining merged rails",
        #                              text, QMessageBox.Yes, QMessageBox.No)
        # if reply != QMessageBox.Yes:
        #     return
        merged_rails_ids_to_joint = []
        fieldIdIdx = self.mergedRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_FIELD_RAIL_ID)
        str_ids = ''
        for i in range(numberOfSelected):
            mergedRailFeature = self.mergedRailsVLayer.selectedFeatures()[i]
            mergedRailId = mergedRailFeature.attributes()[fieldIdIdx]
            if mergedRailId not in merged_rails_ids_to_joint:
                merged_rails_ids_to_joint.append(mergedRailId)
                str_ids = str_ids + str(mergedRailId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        if len(merged_rails_ids_to_joint) < 2:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select two or more merged rails to joint")
            msgBox.exec_()
            return
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtJointMergedRails(dbFileName, merged_rails_ids_to_joint)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        category_field_name = MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_TABLE_FIELD_CATEGORY_SIMBOLOGY
        category_field_index = self.mergedRailsVLayer.fields().indexFromName(category_field_name)
        unique_values = self.mergedRailsVLayer.uniqueValues(category_field_index)
        category_list = []
        for value in unique_values:
            symbol = QgsSymbol.defaultSymbol(self.mergedRailsVLayer.geometryType())
            category = QgsRendererCategory(value, symbol, str(value))
            category_list.append(category)
            symbol.setWidthUnit(QgsUnitTypes.RenderPixels)
            symbol.setWidth(MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_SIMBOLOGY_LINE_WIDTH)
        renderer = QgsCategorizedSymbolRenderer(category_field_name, category_list)
        self.mergedRailsVLayer.setRenderer(renderer)
        qmlMergedRailsFileName = self.templatePath + MMTDefinitions.CONST_SYMBOLOGY_MERGED_RAILS_TEMPLATE
        sldMergedRailsFileName = self.sldFilesPath + MMTDefinitions.CONST_SYMBOLOGY_SLD_MERGED_RAILS_TEMPLATE
        self.mergedRailsVLayer.saveNamedStyle(qmlMergedRailsFileName)
        self.mergedRailsVLayer.saveSldStyle(sldMergedRailsFileName)
        self.mergedRailsVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectRemoveSelectedAiRails(self):
        if not self.aiRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("ai_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.aiRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from ai_rails layer")
            msgBox.exec_()
            return
        text = "Deleted information cannot be recovered"
        text += "\nDo you wish to continue?"
        reply = QMessageBox.question(self.iface.mainWindow(), "Removing AI rails",
                                     text, QMessageBox.Yes, QMessageBox.No)
        if reply != QMessageBox.Yes:
            return
        ai_rails_ids_to_remove = []
        fieldIdIdx = self.aiRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_FIELD_ID)
        str_ids = ''
        for i in range(numberOfSelected):
            aiRailFeature = self.aiRailsVLayer.selectedFeatures()[i]
            aiRailId = aiRailFeature.attributes()[fieldIdIdx]
            ai_rails_ids_to_remove.append(aiRailId)
            str_ids = str_ids + str(aiRailId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtRemoveAiRails(dbFileName, ai_rails_ids_to_remove)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.aiRailsVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectRemoveSelectedCvPhmRails(self):
        if not self.cvPhmRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("cv_phm_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.cvPhmRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from cv_phm_rails layer")
            msgBox.exec_()
            return
        text = "Deleted information cannot be recovered"
        text += "\nDo you wish to continue?"
        reply = QMessageBox.question(self.iface.mainWindow(), "Removing CV and Photogrammetry rails",
                                     text, QMessageBox.Yes, QMessageBox.No)
        if reply != QMessageBox.Yes:
            return
        cv_phm_rails_ids_to_remove = []
        fieldIdIdx = self.cvPhmRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_CV_PHM_RAILS_FIELD_ID)
        str_ids = ''
        for i in range(numberOfSelected):
            cvPhmRailFeature = self.cvPhmRailsVLayer.selectedFeatures()[i]
            cvPhmRailId = cvPhmRailFeature.attributes()[fieldIdIdx]
            cv_phm_rails_ids_to_remove.append(cvPhmRailId)
            str_ids = str_ids + str(cvPhmRailId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtRemoveCvPhmRails(dbFileName, cv_phm_rails_ids_to_remove)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.cvPhmRailsVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectRemoveSelectedMergedRails(self):
        if not self.mergedRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("merged_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.mergedRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from merged_rails layer")
            msgBox.exec_()
            return
        text = "Deleted information cannot be recovered"
        text += "\nDo you wish to continue?"
        reply = QMessageBox.question(self.iface.mainWindow(), "Removing merged rails",
                                     text, QMessageBox.Yes, QMessageBox.No)
        if reply != QMessageBox.Yes:
            return
        merged_rails_ids_to_remove = []
        fieldIdIdx = self.mergedRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_FIELD_RAIL_ID)
        str_ids = ''
        for i in range(numberOfSelected):
            mergedRailFeature = self.mergedRailsVLayer.selectedFeatures()[i]
            mergedRailId = mergedRailFeature.attributes()[fieldIdIdx]
            if mergedRailId not in merged_rails_ids_to_remove:
                merged_rails_ids_to_remove.append(mergedRailId)
                str_ids = str_ids + str(mergedRailId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtRemoveMergedRails(dbFileName, merged_rails_ids_to_remove)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.mergedRailsVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectRemoveSelectedRailwayAxisPoints(self):
        return

    def selectRemoveSelectedRoadMarks(self):
        if not self.roadMarksVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Road marks Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelectedRoadMarks = self.roadMarksVLayer.selectedFeatureCount()
        if numberOfSelectedRoadMarks < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from road marks layer")
            msgBox.exec_()
            return
        text = "Deleted information cannot be recovered"
        text += "\nDo you wish to continue?"
        reply = QMessageBox.question(self.iface.mainWindow(), "Removing Road Marks",
                                     text, QMessageBox.Yes, QMessageBox.No)
        if reply != QMessageBox.Yes:
            return
        road_marks_ids_to_remove = []
        fieldIdIdx = self.roadMarksVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_FIELD_ID)
        str_ids = ''
        for i in range(numberOfSelectedRoadMarks):
            roadMarkFeature = self.roadMarksVLayer.selectedFeatures()[i]
            roadMarkId = roadMarkFeature.attributes()[fieldIdIdx]
            road_marks_ids_to_remove.append(roadMarkId)
            str_ids = str_ids + str(roadMarkId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtRemoveRoadMarks(dbFileName, road_marks_ids_to_remove)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.roadMarksVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectDisableSelectedAiRails(self):
        if not self.aiRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("ai_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.aiRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from ai_rails layer")
            msgBox.exec_()
            return
        ai_rails_ids_to_disable = []
        fieldIdIdx = self.aiRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_FIELD_ID)
        str_ids = ''
        for i in range(numberOfSelected):
            aiRailFeature = self.aiRailsVLayer.selectedFeatures()[i]
            aiRailId = aiRailFeature.attributes()[fieldIdIdx]
            ai_rails_ids_to_disable.append(aiRailId)
            str_ids = str_ids + str(aiRailId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtDisableAiRails(dbFileName, ai_rails_ids_to_disable)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.aiRailsVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectDisableSelectedCvPhmRails(self):
        if not self.cvPhmRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("cv_phm_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.cvPhmRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from cv_phm_rails layer")
            msgBox.exec_()
            return
        cv_phm_rails_ids_to_disable = []
        fieldIdIdx = self.cvPhmRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_CV_PHM_RAILS_FIELD_ID)
        str_ids = ''
        for i in range(numberOfSelected):
            cvPhmRailFeature = self.cvPhmRailsVLayer.selectedFeatures()[i]
            cvPhmRailId = cvPhmRailFeature.attributes()[fieldIdIdx]
            cv_phm_rails_ids_to_disable.append(cvPhmRailId)
            str_ids = str_ids + str(cvPhmRailId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtDisableCvPhmRails(dbFileName, cv_phm_rails_ids_to_disable)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.cvPhmRailsVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectDisableSelectedMergedRails(self):
        if not self.mergedRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("merged_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.mergedRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from merged_rails layer")
            msgBox.exec_()
            return
        merged_rails_ids_to_disable = []
        fieldIdIdx = self.mergedRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_FIELD_RAIL_ID)
        str_ids = ''
        for i in range(numberOfSelected):
            mergedRailFeature = self.mergedRailsVLayer.selectedFeatures()[i]
            mergedRailId = mergedRailFeature.attributes()[fieldIdIdx]
            if mergedRailId not in merged_rails_ids_to_disable:
                merged_rails_ids_to_disable.append(mergedRailId)
                str_ids = str_ids + str(mergedRailId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtDisableMergedRails(dbFileName, merged_rails_ids_to_disable)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.mergedRailsVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectDisableSelectedRoadMarks(self):
        if not self.roadMarksVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Road marks Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelectedRoadMarks = self.roadMarksVLayer.selectedFeatureCount()
        if numberOfSelectedRoadMarks < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from road marks layer")
            msgBox.exec_()
            return
        road_marks_ids_to_disable = []
        fieldIdIdx = self.roadMarksVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_FIELD_ID)
        str_ids = ''
        for i in range(numberOfSelectedRoadMarks):
            roadMarkFeature = self.roadMarksVLayer.selectedFeatures()[i]
            roadMarkId = roadMarkFeature.attributes()[fieldIdIdx]
            road_marks_ids_to_disable.append(roadMarkId)
            str_ids = str_ids + str(roadMarkId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtDisableRoadMarks(dbFileName, road_marks_ids_to_disable)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.roadMarksVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectEnableSelectedAiRails(self):
        if not self.aiRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("ai_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.aiRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from ai_rails layer")
            msgBox.exec_()
            return
        ai_rails_ids_to_enable = []
        fieldIdIdx = self.aiRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_AI_RAILS_FIELD_ID)
        str_ids = ''
        for i in range(numberOfSelected):
            aiRailFeature = self.aiRailsVLayer.selectedFeatures()[i]
            aiRailId = aiRailFeature.attributes()[fieldIdIdx]
            ai_rails_ids_to_enable.append(aiRailId)
            str_ids = str_ids + str(aiRailId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtEnableAiRails(dbFileName, ai_rails_ids_to_enable)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.aiRailsVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectEnableSelectedCvPhmRails(self):
        if not self.cvPhmRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("cv_phm_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.cvPhmRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from cv_phm_rails layer")
            msgBox.exec_()
            return
        cv_phm_rails_ids_to_enable = []
        fieldIdIdx = self.cvPhmRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_CV_PHM_RAILS_FIELD_ID)
        str_ids = ''
        for i in range(numberOfSelected):
            cvPhmRailFeature = self.cvPhmRailsVLayer.selectedFeatures()[i]
            cvPhmRailId = cvPhmRailFeature.attributes()[fieldIdIdx]
            cv_phm_rails_ids_to_enable.append(cvPhmRailId)
            str_ids = str_ids + str(cvPhmRailId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtEnableCvPhmRails(dbFileName, cv_phm_rails_ids_to_enable)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.cvPhmRailsVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectEnableSelectedMergedRails(self):
        if not self.mergedRailsVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("merged_rails Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelected = self.mergedRailsVLayer.selectedFeatureCount()
        if numberOfSelected < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from merged_rails layer")
            msgBox.exec_()
            return
        merged_rails_ids_to_enable = []
        fieldIdIdx = self.mergedRailsVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_MERGED_RAILS_FIELD_RAIL_ID)
        str_ids = ''
        for i in range(numberOfSelected):
            mergedRailFeature = self.mergedRailsVLayer.selectedFeatures()[i]
            mergedRailId = mergedRailFeature.attributes()[fieldIdIdx]
            if mergedRailId not in merged_rails_ids_to_enable:
                merged_rails_ids_to_enable.append(mergedRailId)
                str_ids = str_ids + str(mergedRailId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtEnableMergedRails(dbFileName, merged_rails_ids_to_enable)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.mergedRailsVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectEnableSelectedRoadMarks(self):
        if not self.roadMarksVLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Road marks Layer is not loaded")
            msgBox.exec_()
            return
        numberOfSelectedRoadMarks = self.roadMarksVLayer.selectedFeatureCount()
        if numberOfSelectedRoadMarks < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select some feature from road marks layer")
            msgBox.exec_()
            return
        road_marks_ids_to_enable = []
        fieldIdIdx = self.roadMarksVLayer.dataProvider().fieldNameIndex(
            MMTDefinitions.CONST_SPATIALITE_LAYERS_ROAD_MARKS_FIELD_ID)
        str_ids = ''
        for i in range(numberOfSelectedRoadMarks):
            roadMarkFeature = self.roadMarksVLayer.selectedFeatures()[i]
            roadMarkId = roadMarkFeature.attributes()[fieldIdIdx]
            road_marks_ids_to_enable.append(roadMarkId)
            str_ids = str_ids + str(roadMarkId) + ' '
        # msgBox = QMessageBox(self)
        # msgBox.setIcon(QMessageBox.Information)
        # msgBox.setWindowTitle(self.windowTitle)
        # msgBox.setText("Selected road marks: " + str_ids)
        # msgBox.exec_()
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtEnableRoadMarks(dbFileName, road_marks_ids_to_enable)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.roadMarksVLayer.triggerRepaint()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectRois(self):
        previousFiles = self.roisShapefiles[:]  # copia desligada
        dlg = MultipleFileSelectorDialog(self.iface,
                                         self.path,
                                         MMTDefinitions.CONST_SELECT_ROIS_SHAPEFILES_DIALOG_TITLE,
                                         self.roisFileTypes,
                                         self.roisShapefiles,
                                         self.roisFilesActiveFileExtensions)
        dlg.show()  # show the dialog
        result = dlg.exec_()  # Run the dialog
        self.path = dlg.getPath()
        self.settings.setValue("last_path", self.path)
        files = dlg.getFiles()  # los hay repetidos
        self.roisShapefiles = []
        self.numberOfRoisLineEdit.setText("0")
        for file in files:
            fileBaseName = QFileInfo(file).baseName()
            findFile = False
            for roiFile in self.roisShapefiles:
                if fileBaseName == QFileInfo(roiFile).baseName():
                    findFile = True
                    break
            if not findFile:
                self.roisShapefiles.append(file)
        self.roisFilesActiveFileExtensions = dlg.getActiveFileExtensions()
        self.numberOfRoisLineEdit.setText(str(len(self.roisShapefiles)))
        return

    def selectSaveManuallyEditedLinearRoadMarks(self):
        if not self.manualEditingLinearRoadMarksLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Invalid layer for manually editid linear road marks")
            msgBox.exec_()
            return
        numberOfFeatures = self.manualEditingLinearRoadMarksLayer.featureCount()
        if numberOfFeatures < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Edit some feature in layer " + self.manualEditingLinearRoadMarksLayer.name())
            msgBox.exec_()
            return
        widths = []
        # standarRoadMarksFileNames = []
        wktGeometries = []
        widthsIdx = (self.manualEditingLinearRoadMarksLayer.
                     fields().indexFromName(MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_WIDTH))
        # widthsDictionary = self.manualEditingLinearRoadMarksLayer.editorWidgetSetup(widthsIdx).config().values()
        widths_key_list = list(self.manualEditingLinearRoadMarksLayer.
                               editorWidgetSetup(widthsIdx).config()['map'].keys())
        widths_val_list = list(self.manualEditingLinearRoadMarksLayer.
                               editorWidgetSetup(widthsIdx).config()['map'].values())
        # # standarRoadMarksFileNamesIdx = (self.manualEditingLinearRoadMarksLayer.fields().indexFromName(
        # #     MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_CATALOGUE_FILE))
        # # standarRoadMarksFileNamesDictionary = (self.manualEditingLinearRoadMarksLayer.
        # #                                        editorWidgetSetup(standarRoadMarksFileNamesIdx).config().values())
        # standarRoadMarksFileNames_key_list = list(self.manualEditingLinearRoadMarksLayer.
        #                                           editorWidgetSetup(standarRoadMarksFileNamesIdx).config()[
        #                                               'map'].keys())
        # standarRoadMarksFileNames_val_list = list(self.manualEditingLinearRoadMarksLayer.
        #                                           editorWidgetSetup(standarRoadMarksFileNamesIdx).config()[
        #                                               'map'].values())
        for feature in self.manualEditingLinearRoadMarksLayer.getFeatures():
            wktGeometry = feature.geometry().asWkt()
            widthDictIndex = feature[MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_WIDTH]
            width = -1
            if not widthDictIndex == NULL:
                position = widths_val_list.index(widthDictIndex)
                if position > -1:
                    width = float(widths_key_list[position])
            # standarRoadMarkFileNameDictIndex = feature[
            #     MMTDefinitions.CONST_MANUAL_EDITING_OF_LINEAR_ROAD_MARKS_LAYER_FIELD_CATALOGUE_FILE]
            # standarRoadMarkFileName = ''
            # if not standarRoadMarkFileNameDictIndex == NULL:
            #     position = standarRoadMarksFileNames_val_list.index(standarRoadMarkFileNameDictIndex)
            #     if position > -1:
            #         standarRoadMarkFileName = standarRoadMarksFileNames_key_list[position]
            if width > 0:
                widths.append(width)
                # standarRoadMarksFileNames.append(standarRoadMarkFileName)
                wktGeometries.append(wktGeometry)
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        ret = self.iPyProject.mmtSaveManuallyEditedLinearRoadMarks(dbFileName,
                                                                   widths,
                                                                   # standarRoadMarksFileNames,
                                                                   wktGeometries)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            return
        self.manualEditingLinearRoadMarksLayer.startEditing()
        for feature in self.manualEditingLinearRoadMarksLayer.getFeatures():
            self.manualEditingLinearRoadMarksLayer.deleteFeature(feature.id())
        self.manualEditingLinearRoadMarksLayer.commitChanges()
        self.roadMarksVLayer.triggerRepaint()
        self.manualEditingLinearRoadMarksLayer.startEditing()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()

    def selectSaveManuallyEditedNonLinearRoadMarks(self):
        if not self.manualEditingNonLinearRoadMarksLayer:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Invalid layer for manually edited nonlinear road marks")
            msgBox.exec_()
            return
        numberOfFeatures = self.manualEditingNonLinearRoadMarksLayer.featureCount()
        if numberOfFeatures < 1:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Edit some feature in layer " + self.manualEditingNonLinearRoadMarksLayer.name())
            msgBox.exec_()
            return
        imgs = []
        wktGeometries = []
        for feature in self.manualEditingNonLinearRoadMarksLayer.getFeatures():
            wktGeometry = feature.geometry().asWkt()
            img = feature[MMTDefinitions.CONST_SPATIALITE_LAYERS_STANDARD_ROAD_MARKS_FIELD_IMG]
            if img == NULL: # more than two points are fully digitalized by user
                img = ""
                # continue
            imgs.append(img)
            wktGeometries.append(wktGeometry)
        dbFileName = self.modelManagementConnections[self.projectsComboBox.currentText()]
        if not dbFileName:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Select Db file")
            msgBox.exec_()
            return
        if len(imgs) > 0:
            ret = self.iPyProject.mmtSaveManuallyEditedNonLinearRoadMarks(dbFileName,
                                                                          imgs,
                                                                          wktGeometries)
            if ret[0] == "False":
                msgBox = QMessageBox(self)
                msgBox.setIcon(QMessageBox.Information)
                msgBox.setWindowTitle(self.windowTitle)
                msgBox.setText("Error:\n" + ret[1])
                msgBox.exec_()
                return
        self.manualEditingNonLinearRoadMarksLayer.startEditing()
        for feature in self.manualEditingNonLinearRoadMarksLayer.getFeatures():
            self.manualEditingNonLinearRoadMarksLayer.deleteFeature(feature.id())
        self.manualEditingNonLinearRoadMarksLayer.commitChanges()
        self.roadMarksVLayer.triggerRepaint()
        self.manualEditingNonLinearRoadMarksLayer.startEditing()
        # self.iface.setActiveLayer(self.roadMarksVLayer)
        # self.iface.zoomToActiveLayer()
        return

    def setCrs(self):
        crs = self.projectQgsProjectionSelectionWidget.crs()
        isValidCrs = crs.isValid()
        crsAuthId = crs.authid()
        if not "EPSG:" in crsAuthId:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not EPSG")
            msgBox.exec_()
            self.projectQgsProjectionSelectionWidget.setCrs(
                QgsCoordinateReferenceSystem(MMTDefinitions.CONST_DEFAULT_CRS))
            return
        crsEpsgCode = int(crsAuthId.replace('EPSG:', ''))
        crsOsr = osr.SpatialReference()  # define test1
        if crsOsr.ImportFromEPSG(crsEpsgCode) != 0:
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error importing OSR CRS from EPSG code" + str(crsEpsgCode))
            msgBox.exec_()
            self.projectQgsProjectionSelectionWidget.setCrs(
                QgsCoordinateReferenceSystem(MMTDefinitions.CONST_DEFAULT_CRS))
            return
        if not crsOsr.IsProjected():
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Selected CRS is not a projected CRS")
            msgBox.exec_()
            self.projectQgsProjectionSelectionWidget.setCrs(
                QgsCoordinateReferenceSystem(MMTDefinitions.CONST_DEFAULT_CRS))
            return
        self.setVerticalCRSs(crsEpsgCode)
        crsEpsgCodeString = 'EPSG:' + str(crsEpsgCode)
        # self.addPCFsQgsProjectionSelectionWidget.setCrs(
        #     QgsCoordinateReferenceSystem(crsEpsgCodeString))
        self.crsEpsgCode = crsEpsgCode

    def setVerticalCRSs(self, crsEpsgCode):
        self.verticalCRSsComboBox.clear()
        self.verticalCRSsComboBox.addItem(MMTDefinitions.CONST_ELLIPSOID_HEIGHT)
        ret = self.iPyProject.mmtGetVerticalCRSs(crsEpsgCode)
        if ret[0] == "False":
            msgBox = QMessageBox(self)
            msgBox.setIcon(QMessageBox.Information)
            msgBox.setWindowTitle(self.windowTitle)
            msgBox.setText("Error:\n" + ret[1])
            msgBox.exec_()
            # self.projectsComboBox.setCurrentIndex(0)
            return
        else:
            cont = 0
            for value in ret:
                if cont > 0:
                    # strCrs = qLidarDefinitions.CONST_EPSG_PREFIX + str(value)
                    self.verticalCRSsComboBox.addItem(value)
                cont = cont + 1
            # msgBox = QMessageBox(self)
            # msgBox.setIcon(QMessageBox.Information)
            # msgBox.setWindowTitle(self.windowTitle)
            # msgBox.setText("Process completed successfully")
            # msgBox.exec_()
        strCrs = MMTDefinitions.CONST_EPSG_PREFIX + str(crsEpsgCode)
        if strCrs == MMTDefinitions.CONST_DEFAULT_CRS:
            index = self.verticalCRSsComboBox.findText(
                MMTDefinitions.CONST_DEFAULT_VERTICAL_CRS)  # , QtCore.Qt.MatchFixedString)
            if index > 0:
                self.verticalCRSsComboBox.setCurrentIndex(index)
        return
